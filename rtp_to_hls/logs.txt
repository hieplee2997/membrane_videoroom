
11:02:43.225 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []


11:02:43.254 [debug] [pipeline@<0.322.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106488>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]


11:02:43.270 [debug] [pipeline@<0.322.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.270 [debug] [pipeline@<0.322.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:43.273 [debug] [pipeline@<0.322.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []


11:02:43.286 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:43.288 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source

11:02:43.293 [debug] [pipeline@<0.322.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink

11:02:43.293 [debug] [pipeline@<0.322.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:43.293 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:43.295 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink

11:02:43.295 [debug] [pipeline@<0.322.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin

11:02:43.298 [debug] [pipeline@<0.322.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []


11:02:43.302 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:43.304 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.304 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:43.304 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []


11:02:43.304 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:43.304 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter

11:02:43.322 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333185.106488>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333185.106488>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106488>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333185.106488>}}], status: :done}]


11:02:43.323 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333185.106488>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.323 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333185.106488>}, module: Membrane.RTP.Parser

11:02:43.323 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333185.106488>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []


11:02:43.323 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106488>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:43.323 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106488>}] Element initialized: Membrane.RTP.Parser

11:02:43.333 [debug] [pipeline@<0.322.0>] Changing playback state from stopped to prepared

11:02:43.333 [debug] [:rtp bin] Changing playback state from stopped to prepared
Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)

11:02:43.337 [debug] [:rtp bin] Playback state changed from stopped to prepared

11:02:43.344 [debug] [pipeline@<0.322.0>] Playback state changed from stopped to prepared

11:02:43.344 [debug] [pipeline@<0.322.0>] Changing playback state from prepared to playing

11:02:43.344 [debug] [:rtp bin] Changing playback state from prepared to playing

11:02:43.345 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106488>}] Evaluating playback buffer

11:02:43.345 [debug] [:hls] Evaluating playback buffer

11:02:43.354 [debug] [:app_source] Sending caps through pad :output
Caps: %Membrane.RemoteStream{content_format: nil, type: :packetized}


11:02:43.358 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []


11:02:43.358 [debug] [pipeline@<0.331.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.98951>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]


11:02:43.358 [debug] [pipeline@<0.331.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.358 [debug] [pipeline@<0.331.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:43.358 [debug] [pipeline@<0.331.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []


11:02:43.358 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:43.358 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source

11:02:43.358 [debug] [pipeline@<0.331.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink

11:02:43.358 [debug] [pipeline@<0.331.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:43.359 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:43.359 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink

11:02:43.359 [debug] [pipeline@<0.331.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin

11:02:43.359 [debug] [pipeline@<0.331.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []


11:02:43.359 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:43.359 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.359 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:43.359 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []


11:02:43.359 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:43.359 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter

11:02:43.359 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333187.98951>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333187.98951>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.98951>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333187.98951>}}], status: :done}]


11:02:43.359 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333187.98951>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.359 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333187.98951>}, module: Membrane.RTP.Parser

11:02:43.359 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333187.98951>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []


11:02:43.359 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.98951>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:43.359 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.98951>}] Element initialized: Membrane.RTP.Parser

11:02:43.360 [debug] [pipeline@<0.331.0>] Changing playback state from stopped to prepared

11:02:43.360 [debug] [:rtp bin] Changing playback state from stopped to prepared

11:02:43.360 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}


11:02:43.360 [debug] [:rtp bin] Playback state changed from stopped to prepared

11:02:43.364 [debug] [:ssrc_router] Evaluating playback buffer

11:02:43.368 [debug] [:app_source] Evaluating playback buffer

11:02:43.370 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106488>}] Received caps on pad :input
Caps: %Membrane.RemoteStream{content_format: nil, type: :packetized}


11:02:43.371 [debug] [:rtp bin] Playback state changed from prepared to playing
iex(1)> 
11:02:43.375 [debug] [pipeline@<0.322.0>] Playback state changed from prepared to playing
iex(1)> 
11:02:43.382 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106488>}] Sending caps through pad :output
Caps: %Membrane.RTP{}

iex(1)> 
11:02:43.382 [debug] [:ssrc_router] Received caps on pad {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106651>}
Caps: %Membrane.RTP{}

iex(1)> 
11:02:43.386 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.331.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.98951>},
        pid: #PID<0.335.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.98953>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.332.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.331.0>
}

iex(1)> 
11:02:43.386 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.331.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.98951>},
        pid: #PID<0.335.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.98953>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.332.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.331.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.331.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.98951>},
        pid: #PID<0.335.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.98953>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.332.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.331.0>
}

iex(1)> 
11:02:43.386 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.331.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.98951>},
        pid: #PID<0.335.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.98953>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.332.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.331.0>
}

iex(1)> 
11:02:43.391 [error] GenServer #PID<0.333.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.331.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.98951>}, pid: #PID<0.335.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333187.98953>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.332.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.331.0>}
iex(1)> 
11:02:43.402 [debug] [pipeline@<0.331.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.

iex(1)> 
11:02:43.402 [debug] [pipeline@<0.331.0>] A child crashed but was not a member of any crash group.
Terminating.

iex(1)> ** (EXIT from #PID<0.330.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.404 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:43.405 [debug] [pipeline@<0.341.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106698>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:43.406 [debug] [pipeline@<0.341.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:43.406 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.331.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.98957>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.332.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.331.0>
}


11:02:43.406 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.331.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.98957>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.332.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.331.0>
}


11:02:43.406 [debug] [pipeline@<0.341.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source
iex(1)> 
11:02:43.406 [debug] [pipeline@<0.341.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []

iex(1)> 
11:02:43.406 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.331.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.98957>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.332.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.331.0>
}

iex(1)> 
11:02:43.407 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}
iex(1)> 
11:02:43.408 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source
iex(1)> 
11:02:43.408 [debug] [pipeline@<0.341.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.408 [debug] [pipeline@<0.341.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:43.408 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:43.408 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink

11:02:43.408 [debug] [pipeline@<0.341.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin

11:02:43.408 [debug] [pipeline@<0.341.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []


11:02:43.408 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:43.408 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.408 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:43.408 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []


11:02:43.408 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:43.408 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter

11:02:43.409 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333185.106698>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333185.106698>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106698>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333185.106698>}}], status: :done}]


11:02:43.409 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333185.106698>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.409 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333185.106698>}, module: Membrane.RTP.Parser

11:02:43.409 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333185.106698>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []


11:02:43.409 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106698>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:43.409 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106698>}] Element initialized: Membrane.RTP.Parser
iex(1)> iex(1)> ** (EXIT from #PID<0.340.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:43.409 [debug] [pipeline@<0.341.0>] Changing playback state from stopped to prepared

11:02:43.409 [debug] [:rtp bin] Changing playback state from stopped to prepared

11:02:43.410 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}


11:02:43.410 [debug] [:rtp bin] Playback state changed from stopped to prepared

11:02:43.410 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.341.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106698>},
        pid: #PID<0.345.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106700>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.342.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.341.0>
}


11:02:43.410 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.341.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106698>},
        pid: #PID<0.345.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106700>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.342.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.341.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.341.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106698>},
        pid: #PID<0.345.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106700>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.342.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.341.0>
}


11:02:43.410 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.341.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106698>},
        pid: #PID<0.345.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106700>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.342.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.341.0>
}


11:02:43.410 [error] GenServer #PID<0.343.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.341.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106698>}, pid: #PID<0.345.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333185.106700>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.342.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.341.0>}

11:02:43.411 [debug] [pipeline@<0.341.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.


11:02:43.411 [debug] [pipeline@<0.341.0>] A child crashed but was not a member of any crash group.
Terminating.


11:02:43.411 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.341.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96735>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.342.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.341.0>
}


11:02:43.411 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.341.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96735>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.342.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.341.0>
}


11:02:43.412 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.341.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96735>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.342.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.341.0>
}

iex(1)> 
iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.427 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:43.427 [debug] [pipeline@<0.351.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99022>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:43.427 [debug] [pipeline@<0.351.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:43.427 [debug] [pipeline@<0.351.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:43.427 [debug] [pipeline@<0.351.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []

iex(1)> 
11:02:43.427 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:43.427 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source
iex(1)> 
11:02:43.427 [debug] [pipeline@<0.351.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.427 [debug] [pipeline@<0.351.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:43.427 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:43.428 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.428 [debug] [pipeline@<0.351.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin
iex(1)> 
11:02:43.428 [debug] [pipeline@<0.351.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []

iex(1)> 
11:02:43.428 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:43.428 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.428 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:43.428 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []

iex(1)> 
11:02:43.428 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:43.428 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:43.428 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333187.99022>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333187.99022>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99022>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333187.99022>}}], status: :done}]

iex(1)> 
11:02:43.428 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333187.99022>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.428 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333187.99022>}, module: Membrane.RTP.Parser

11:02:43.429 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333187.99022>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []

iex(1)> 
11:02:43.429 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99022>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:43.429 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99022>}] Element initialized: Membrane.RTP.Parser
iex(1)> 
11:02:43.429 [debug] [pipeline@<0.351.0>] Changing playback state from stopped to prepared
iex(1)> 
11:02:43.430 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> iex(1)> 
11:02:43.430 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> 
11:02:43.430 [debug] [:rtp bin] Playback state changed from stopped to prepared

11:02:43.430 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.351.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99022>},
        pid: #PID<0.355.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99027>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.352.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.351.0>
}

iex(1)> 
11:02:43.431 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.351.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99022>},
        pid: #PID<0.355.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99027>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.352.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.351.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.351.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99022>},
        pid: #PID<0.355.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99027>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.352.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.351.0>
}

iex(1)> 
11:02:43.431 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.351.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99022>},
        pid: #PID<0.355.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99027>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.352.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.351.0>
}

iex(1)> 
11:02:43.431 [error] GenServer #PID<0.353.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.351.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99022>}, pid: #PID<0.355.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333187.99027>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.352.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.351.0>}
iex(1)> 
11:02:43.431 [debug] [pipeline@<0.351.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.


11:02:43.431 [debug] [pipeline@<0.351.0>] A child crashed but was not a member of any crash group.
Terminating.

iex(1)> ** (EXIT from #PID<0.350.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:43.431 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.351.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99033>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.352.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.351.0>
}


11:02:43.431 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.351.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99033>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.352.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.351.0>
}


11:02:43.432 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.351.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99033>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.352.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.351.0>
}

iex(1)> 
iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.439 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:43.439 [debug] [pipeline@<0.361.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99102>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:43.439 [debug] [pipeline@<0.361.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:43.439 [debug] [pipeline@<0.361.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:43.439 [debug] [pipeline@<0.361.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []

iex(1)> 
11:02:43.439 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:43.439 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source
iex(1)> 
11:02:43.439 [debug] [pipeline@<0.361.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.439 [debug] [pipeline@<0.361.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:43.439 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:43.439 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.439 [debug] [pipeline@<0.361.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin
iex(1)> 
11:02:43.439 [debug] [pipeline@<0.361.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []

iex(1)> 
11:02:43.440 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:43.440 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.440 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:43.440 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []

iex(1)> 
11:02:43.440 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:43.440 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:43.440 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333187.99102>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333187.99102>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99102>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333187.99102>}}], status: :done}]

iex(1)> 
11:02:43.440 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333187.99102>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.440 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333187.99102>}, module: Membrane.RTP.Parser

11:02:43.440 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333187.99102>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []

iex(1)> 
11:02:43.440 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99102>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:43.440 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99102>}] Element initialized: Membrane.RTP.Parser
iex(1)> 
11:02:43.440 [debug] [pipeline@<0.361.0>] Changing playback state from stopped to prepared
iex(1)> 
11:02:43.440 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> iex(1)> 
11:02:43.441 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> 
11:02:43.441 [debug] [:rtp bin] Playback state changed from stopped to prepared

11:02:43.441 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.361.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99102>},
        pid: #PID<0.365.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99107>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.362.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.361.0>
}

iex(1)> 
11:02:43.441 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.361.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99102>},
        pid: #PID<0.365.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99107>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.362.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.361.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.361.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99102>},
        pid: #PID<0.365.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99107>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.362.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.361.0>
}

iex(1)> 
11:02:43.442 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.361.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99102>},
        pid: #PID<0.365.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99107>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.362.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.361.0>
}

iex(1)> 
11:02:43.442 [error] GenServer #PID<0.363.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.361.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99102>}, pid: #PID<0.365.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333187.99107>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.362.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.361.0>}
iex(1)> 
11:02:43.442 [debug] [pipeline@<0.361.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.


11:02:43.442 [debug] [pipeline@<0.361.0>] A child crashed but was not a member of any crash group.
Terminating.

iex(1)> ** (EXIT from #PID<0.360.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:43.442 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.361.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99113>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.362.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.361.0>
}

iex(1)> 
iex(1)> 
11:02:43.442 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.361.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99113>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.362.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.361.0>
}

iex(1)> 
11:02:43.443 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.361.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99113>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.362.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.361.0>
}

iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.445 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.98951>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.335.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.98951>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.98951>},
        pid: #PID<0.335.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.98983>},
        pid: #PID<0.337.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.98979>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.336.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.335.0>
}

iex(1)> 
11:02:43.446 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333187.98951>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.335.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.98951>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.98951>},
        pid: #PID<0.335.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.98983>},
        pid: #PID<0.337.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.98979>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.336.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.335.0>
}

iex(1)> 
11:02:43.446 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333187.98951>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.335.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.98951>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.98951>},
        pid: #PID<0.335.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.98983>},
        pid: #PID<0.337.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.98979>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.336.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.335.0>
}

iex(1)> 
11:02:43.448 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:43.448 [debug] [pipeline@<0.371.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333186.97394>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> iex(1)> 
11:02:43.448 [debug] [pipeline@<0.371.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.448 [debug] [pipeline@<0.371.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:43.448 [debug] [pipeline@<0.371.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []


11:02:43.448 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:43.448 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source

11:02:43.448 [debug] [pipeline@<0.371.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink

11:02:43.448 [debug] [pipeline@<0.371.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:43.448 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:43.448 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink

11:02:43.448 [debug] [pipeline@<0.371.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin

11:02:43.448 [debug] [pipeline@<0.371.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []


11:02:43.449 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:43.449 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.449 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:43.449 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []


11:02:43.449 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:43.449 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter

11:02:43.449 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333186.97394>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333186.97394>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333186.97394>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333186.97394>}}], status: :done}]


11:02:43.449 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333186.97394>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.449 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333186.97394>}, module: Membrane.RTP.Parser

11:02:43.449 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333186.97394>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []


11:02:43.449 [debug] [{:rtp_parser, #Reference<0.2271929081.730333186.97394>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:43.449 [debug] [{:rtp_parser, #Reference<0.2271929081.730333186.97394>}] Element initialized: Membrane.RTP.Parser

11:02:43.449 [debug] [pipeline@<0.371.0>] Changing playback state from stopped to prepared

11:02:43.449 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> 
11:02:43.449 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> 
11:02:43.450 [debug] [:rtp bin] Playback state changed from stopped to prepared
iex(1)> 
11:02:43.450 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.371.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97394>},
        pid: #PID<0.375.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97396>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.372.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.371.0>
}

iex(1)> 
11:02:43.450 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.371.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97394>},
        pid: #PID<0.375.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97396>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.372.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.371.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.371.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97394>},
        pid: #PID<0.375.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97396>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.372.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.371.0>
}


11:02:43.450 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.371.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97394>},
        pid: #PID<0.375.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97396>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.372.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.371.0>
}


11:02:43.450 [error] GenServer #PID<0.373.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.371.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333186.97394>}, pid: #PID<0.375.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333186.97396>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.372.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.371.0>}

11:02:43.451 [debug] [pipeline@<0.371.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.


11:02:43.451 [debug] [pipeline@<0.371.0>] A child crashed but was not a member of any crash group.
Terminating.


11:02:43.451 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.371.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97400>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.372.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.371.0>
}


11:02:43.451 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.371.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97400>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.372.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.371.0>
}


11:02:43.451 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.371.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97400>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.372.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.371.0>
}

iex(1)> 
11:02:43.452 [debug] [{:rtp_parser, #Reference<0.2271929081.730333186.97394>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.375.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333186.97394>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333186.97394>},
        pid: #PID<0.375.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333186.97427>},
        pid: #PID<0.377.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97423>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.376.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.375.0>
}

iex(1)> ** (EXIT from #PID<0.370.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:43.452 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333186.97394>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.375.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333186.97394>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333186.97394>},
        pid: #PID<0.375.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333186.97427>},
        pid: #PID<0.377.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97423>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.376.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.375.0>
}


11:02:43.452 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333186.97394>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.375.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333186.97394>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333186.97394>},
        pid: #PID<0.375.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333186.97427>},
        pid: #PID<0.377.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97423>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.376.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.375.0>
}

iex(1)> 
iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.457 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:43.458 [debug] [pipeline@<0.381.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99199>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:43.458 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106698>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.345.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.106698>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.106698>},
        pid: #PID<0.345.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.96760>},
        pid: #PID<0.347.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96756>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.346.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.345.0>
}


11:02:43.458 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.345.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96760>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.96760>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.348.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96760>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96741>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.346.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.345.0>
}


11:02:43.459 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.335.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.98983>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.98983>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.338.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.98983>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.98963>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.336.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.335.0>
}


11:02:43.459 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99022>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.355.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99022>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99022>},
        pid: #PID<0.355.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99066>},
        pid: #PID<0.357.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99061>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.356.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.355.0>
}


11:02:43.459 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.345.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96760>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.96760>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.348.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96760>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96741>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.346.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.345.0>
}


11:02:43.459 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333185.106698>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.345.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.106698>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.106698>},
        pid: #PID<0.345.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.96760>},
        pid: #PID<0.347.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96756>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.346.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.345.0>
}


11:02:43.459 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.355.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99066>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99066>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.358.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99066>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99043>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.356.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.355.0>
}


11:02:43.459 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99102>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.365.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99102>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99102>},
        pid: #PID<0.365.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99146>},
        pid: #PID<0.367.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99141>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.366.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.365.0>
}


11:02:43.459 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.375.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97427>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333186.97427>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.378.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97427>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97406>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.376.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.375.0>
}


11:02:43.459 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.365.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99146>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99146>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.368.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99146>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99123>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.366.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.365.0>
}

iex(1)> 
11:02:43.459 [debug] [pipeline@<0.381.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.460 [debug] [pipeline@<0.381.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:43.460 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.375.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97427>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333186.97427>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.378.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97427>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97406>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.376.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.375.0>
}


11:02:43.460 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.375.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97427>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333186.97427>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.378.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97427>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97406>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.376.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.375.0>
}


11:02:43.460 [debug] [pipeline@<0.381.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []

iex(1)> 
11:02:43.460 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.365.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99146>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99146>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.368.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99146>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99123>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.366.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.365.0>
}


11:02:43.460 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:43.460 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source

11:02:43.460 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.365.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99146>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99146>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.368.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99146>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99123>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.366.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.365.0>
}


11:02:43.460 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.335.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.98983>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.98983>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.338.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.98983>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.98963>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.336.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.335.0>
}


11:02:43.460 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333187.99022>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.355.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99022>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99022>},
        pid: #PID<0.355.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99066>},
        pid: #PID<0.357.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99061>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.356.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.355.0>
}


11:02:43.460 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.355.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99066>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99066>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.358.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99066>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99043>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.356.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.355.0>
}


11:02:43.461 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.345.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96760>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.96760>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.348.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96760>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96741>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.346.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.345.0>
}


11:02:43.461 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.335.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.98983>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.98983>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.338.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.98983>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.98963>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.336.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.335.0>
}


11:02:43.461 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333185.106698>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.345.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.106698>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.106698>},
        pid: #PID<0.345.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.96760>},
        pid: #PID<0.347.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96756>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.346.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.345.0>
}


11:02:43.461 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333187.99022>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.355.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99022>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99022>},
        pid: #PID<0.355.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99066>},
        pid: #PID<0.357.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99061>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.356.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.355.0>
}

iex(1)> 
11:02:43.461 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.355.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99066>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99066>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.358.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99066>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99043>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.356.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.355.0>
}


11:02:43.461 [debug] [pipeline@<0.381.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.461 [debug] [pipeline@<0.381.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:43.461 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:43.461 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink

11:02:43.461 [debug] [pipeline@<0.381.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin

11:02:43.461 [debug] [pipeline@<0.381.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []


11:02:43.461 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:43.461 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.461 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:43.461 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []


11:02:43.462 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:43.462 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter

11:02:43.462 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333187.99199>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333187.99199>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99199>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333187.99199>}}], status: :done}]


11:02:43.462 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333187.99199>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.462 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333187.99199>}, module: Membrane.RTP.Parser

11:02:43.462 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333187.99199>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []


11:02:43.462 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99199>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:43.462 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99199>}] Element initialized: Membrane.RTP.Parser
iex(1)> 
11:02:43.463 [debug] [pipeline@<0.381.0>] Changing playback state from stopped to prepared
iex(1)> iex(1)> 
11:02:43.463 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> 
11:02:43.463 [debug] [:rtp bin] Playback state changed from stopped to prepared
iex(1)> 
11:02:43.463 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> 
11:02:43.463 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.381.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99199>},
        pid: #PID<0.385.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99204>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.382.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.381.0>
}

iex(1)> 
11:02:43.464 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.381.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99199>},
        pid: #PID<0.385.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99204>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.382.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.381.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.381.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99199>},
        pid: #PID<0.385.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99204>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.382.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.381.0>
}

iex(1)> 
11:02:43.464 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.381.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99199>},
        pid: #PID<0.385.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99204>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.382.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.381.0>
}

iex(1)> 
11:02:43.464 [error] GenServer #PID<0.383.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.381.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99199>}, pid: #PID<0.385.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333187.99204>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.382.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.381.0>}
iex(1)> 
11:02:43.464 [debug] [pipeline@<0.381.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.


11:02:43.464 [debug] [pipeline@<0.381.0>] A child crashed but was not a member of any crash group.
Terminating.

iex(1)> 
11:02:43.465 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99199>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.385.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99199>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99199>},
        pid: #PID<0.385.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99233>},
        pid: #PID<0.387.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99229>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.386.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.385.0>
}

iex(1)> ** (EXIT from #PID<0.380.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:43.465 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.381.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99208>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.382.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.381.0>
}

iex(1)> 
11:02:43.465 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.385.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99233>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99233>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.388.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99233>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99214>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.386.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.385.0>
}


11:02:43.466 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333187.99199>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.385.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99199>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99199>},
        pid: #PID<0.385.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99233>},
        pid: #PID<0.387.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99229>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.386.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.385.0>
}

iex(1)> 
iex(1)> 
11:02:43.466 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.381.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99208>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.382.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.381.0>
}

iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.466 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333187.99102>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.365.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99102>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99102>},
        pid: #PID<0.365.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99146>},
        pid: #PID<0.367.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99141>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.366.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.365.0>
}


11:02:43.466 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333187.99102>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.365.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99102>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99102>},
        pid: #PID<0.365.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99146>},
        pid: #PID<0.367.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99141>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.366.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.365.0>
}


11:02:43.467 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333187.99199>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.385.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99199>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99199>},
        pid: #PID<0.385.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99233>},
        pid: #PID<0.387.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99229>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.386.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.385.0>
}


11:02:43.467 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.381.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99208>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.382.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.381.0>
}


11:02:43.467 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.385.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99233>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99233>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.388.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99233>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99214>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.386.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.385.0>
}

iex(1)> 
11:02:43.467 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.385.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99233>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99233>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.388.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99233>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99214>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.386.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.385.0>
}

iex(1)> 
11:02:43.468 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:43.468 [debug] [pipeline@<0.391.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106713>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:43.468 [debug] [pipeline@<0.391.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:43.468 [debug] [pipeline@<0.391.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:43.469 [debug] [pipeline@<0.391.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []

iex(1)> 
11:02:43.469 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:43.469 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source
iex(1)> 
11:02:43.469 [debug] [pipeline@<0.391.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.469 [debug] [pipeline@<0.391.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:43.469 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:43.469 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.469 [debug] [pipeline@<0.391.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin
iex(1)> 
11:02:43.469 [debug] [pipeline@<0.391.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []

iex(1)> 
11:02:43.469 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:43.469 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.469 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:43.469 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []

iex(1)> 
11:02:43.470 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:43.470 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:43.470 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333185.106713>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333185.106713>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106713>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333185.106713>}}], status: :done}]

iex(1)> 
11:02:43.470 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333185.106713>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.470 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333185.106713>}, module: Membrane.RTP.Parser

11:02:43.470 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333185.106713>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []

iex(1)> 
11:02:43.470 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106713>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:43.470 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106713>}] Element initialized: Membrane.RTP.Parser
iex(1)> 
11:02:43.470 [debug] [pipeline@<0.391.0>] Changing playback state from stopped to prepared
iex(1)> 
11:02:43.470 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> 
11:02:43.470 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> iex(1)> 
11:02:43.471 [debug] [:rtp bin] Playback state changed from stopped to prepared

11:02:43.471 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.391.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106713>},
        pid: #PID<0.395.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106718>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.392.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.391.0>
}

iex(1)> 
11:02:43.471 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.391.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106713>},
        pid: #PID<0.395.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106718>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.392.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.391.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.391.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106713>},
        pid: #PID<0.395.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106718>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.392.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.391.0>
}

iex(1)> 
11:02:43.471 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.391.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106713>},
        pid: #PID<0.395.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106718>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.392.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.391.0>
}


11:02:43.471 [error] GenServer #PID<0.393.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.391.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106713>}, pid: #PID<0.395.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333185.106718>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.392.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.391.0>}

11:02:43.471 [debug] [pipeline@<0.391.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.


11:02:43.471 [debug] [pipeline@<0.391.0>] A child crashed but was not a member of any crash group.
Terminating.

iex(1)> ** (EXIT from #PID<0.390.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:43.472 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.391.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106724>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.392.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.391.0>
}


11:02:43.472 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.391.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106724>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.392.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.391.0>
}


11:02:43.472 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.391.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106724>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.392.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.391.0>
}


11:02:43.472 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106713>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.395.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.106713>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.106713>},
        pid: #PID<0.395.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.106757>},
        pid: #PID<0.397.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106752>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.396.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.395.0>
}


11:02:43.472 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333185.106713>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.395.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.106713>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.106713>},
        pid: #PID<0.395.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.106757>},
        pid: #PID<0.397.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106752>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.396.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.395.0>
}


11:02:43.473 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333185.106713>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.395.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.106713>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.106713>},
        pid: #PID<0.395.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.106757>},
        pid: #PID<0.397.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106752>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.396.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.395.0>
}


11:02:43.473 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.395.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106757>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.106757>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.398.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106757>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106734>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.396.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.395.0>
}


11:02:43.473 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.395.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106757>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.106757>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.398.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106757>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106734>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.396.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.395.0>
}


11:02:43.473 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.395.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106757>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.106757>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.398.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106757>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106734>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.396.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.395.0>
}

iex(1)> 
iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.569 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:43.570 [debug] [pipeline@<0.401.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333186.97475>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:43.570 [debug] [pipeline@<0.401.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:43.570 [debug] [pipeline@<0.401.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:43.570 [debug] [pipeline@<0.401.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []

iex(1)> 
11:02:43.570 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:43.570 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source
iex(1)> 
11:02:43.570 [debug] [pipeline@<0.401.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.570 [debug] [pipeline@<0.401.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:43.571 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:43.571 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.571 [debug] [pipeline@<0.401.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin
iex(1)> 
11:02:43.571 [debug] [pipeline@<0.401.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []

iex(1)> 
11:02:43.571 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:43.571 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.571 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:43.571 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []

iex(1)> 
11:02:43.571 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:43.571 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:43.571 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333186.97475>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333186.97475>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333186.97475>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333186.97475>}}], status: :done}]

iex(1)> 
11:02:43.571 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333186.97475>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.571 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333186.97475>}, module: Membrane.RTP.Parser

11:02:43.571 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333186.97475>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []

iex(1)> 
11:02:43.572 [debug] [{:rtp_parser, #Reference<0.2271929081.730333186.97475>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:43.572 [debug] [{:rtp_parser, #Reference<0.2271929081.730333186.97475>}] Element initialized: Membrane.RTP.Parser
iex(1)> 
11:02:43.572 [debug] [pipeline@<0.401.0>] Changing playback state from stopped to prepared
iex(1)> 
11:02:43.572 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> iex(1)> 
11:02:43.572 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}


11:02:43.572 [debug] [:rtp bin] Playback state changed from stopped to prepared
iex(1)> 
11:02:43.573 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.401.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97475>},
        pid: #PID<0.405.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97480>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.402.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.401.0>
}

iex(1)> 
11:02:43.574 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.401.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97475>},
        pid: #PID<0.405.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97480>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.402.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.401.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.401.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97475>},
        pid: #PID<0.405.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97480>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.402.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.401.0>
}

iex(1)> 
11:02:43.574 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.401.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97475>},
        pid: #PID<0.405.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97480>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.402.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.401.0>
}

iex(1)> 
11:02:43.574 [error] GenServer #PID<0.403.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.401.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333186.97475>}, pid: #PID<0.405.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333186.97480>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.402.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.401.0>}
iex(1)> 
11:02:43.574 [debug] [pipeline@<0.401.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.

iex(1)> 
11:02:43.574 [debug] [pipeline@<0.401.0>] A child crashed but was not a member of any crash group.
Terminating.

iex(1)> 
11:02:43.575 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.401.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97486>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.402.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.401.0>
}

iex(1)> 
11:02:43.575 [debug] [{:rtp_parser, #Reference<0.2271929081.730333186.97475>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.405.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333186.97475>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333186.97475>},
        pid: #PID<0.405.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333186.97519>},
        pid: #PID<0.407.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97514>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.406.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.405.0>
}


11:02:43.576 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333186.97475>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.405.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333186.97475>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333186.97475>},
        pid: #PID<0.405.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333186.97519>},
        pid: #PID<0.407.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97514>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.406.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.405.0>
}


11:02:43.576 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333186.97475>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.405.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333186.97475>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333186.97475>},
        pid: #PID<0.405.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333186.97519>},
        pid: #PID<0.407.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97514>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.406.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.405.0>
}


11:02:43.575 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.401.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97486>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.402.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.401.0>
}

iex(1)> 
11:02:43.576 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.405.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97519>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333186.97519>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.408.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97519>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97496>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.406.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.405.0>
}

iex(1)> ** (EXIT from #PID<0.400.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:43.576 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.401.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97486>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.402.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.401.0>
}

iex(1)> 
iex(1)> 
11:02:43.577 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.405.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97519>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333186.97519>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.408.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97519>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97496>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.406.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.405.0>
}


11:02:43.577 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.405.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97519>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333186.97519>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.408.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97519>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97496>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.406.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.405.0>
}

iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.579 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:43.579 [debug] [pipeline@<0.411.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.96795>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:43.580 [debug] [pipeline@<0.411.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:43.580 [debug] [pipeline@<0.411.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:43.581 [debug] [pipeline@<0.411.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []

iex(1)> 
11:02:43.581 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:43.581 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source
iex(1)> 
11:02:43.581 [debug] [pipeline@<0.411.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.581 [debug] [pipeline@<0.411.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:43.582 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:43.583 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.583 [debug] [pipeline@<0.411.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin
iex(1)> 
11:02:43.583 [debug] [pipeline@<0.411.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []

iex(1)> 
11:02:43.583 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []

iex(1)> 
11:02:43.583 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.583 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:43.583 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []


11:02:43.583 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:43.583 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:43.584 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333188.96795>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333188.96795>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.96795>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333188.96795>}}], status: :done}]

iex(1)> 
11:02:43.584 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333188.96795>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.584 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333188.96795>}, module: Membrane.RTP.Parser
iex(1)> 
11:02:43.584 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333188.96795>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []

iex(1)> 
11:02:43.584 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.96795>}] Initializing element: Membrane.RTP.Parser, options: nil
iex(1)> 
11:02:43.584 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.96795>}] Element initialized: Membrane.RTP.Parser
iex(1)> 
11:02:43.584 [debug] [pipeline@<0.411.0>] Changing playback state from stopped to prepared
iex(1)> 
11:02:43.584 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> iex(1)> 
11:02:43.585 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> 
11:02:43.585 [debug] [:rtp bin] Playback state changed from stopped to prepared
iex(1)> 
11:02:43.585 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.411.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.96795>},
        pid: #PID<0.415.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96800>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.412.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.411.0>
}

iex(1)> 
11:02:43.585 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.411.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.96795>},
        pid: #PID<0.415.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96800>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.412.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.411.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.411.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.96795>},
        pid: #PID<0.415.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96800>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.412.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.411.0>
}

iex(1)> 
11:02:43.586 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.411.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.96795>},
        pid: #PID<0.415.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96800>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.412.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.411.0>
}

iex(1)> 
11:02:43.586 [error] GenServer #PID<0.413.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.411.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.96795>}, pid: #PID<0.415.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333188.96800>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.412.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.411.0>}
iex(1)> 
11:02:43.586 [debug] [pipeline@<0.411.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.

iex(1)> 
11:02:43.586 [debug] [pipeline@<0.411.0>] A child crashed but was not a member of any crash group.
Terminating.

iex(1)> ** (EXIT from #PID<0.410.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:43.586 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.411.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96806>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.412.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.411.0>
}

iex(1)> 
iex(1)> 
11:02:43.586 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.411.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96806>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.412.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.411.0>
}

iex(1)> 
11:02:43.587 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.96795>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.415.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.96795>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.96795>},
        pid: #PID<0.415.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.96824>},
        pid: #PID<0.417.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99263>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.416.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.415.0>
}


11:02:43.587 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.411.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96806>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.412.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.411.0>
}

iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.587 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333188.96795>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.415.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.96795>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.96795>},
        pid: #PID<0.415.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.96824>},
        pid: #PID<0.417.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99263>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.416.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.415.0>
}

iex(1)> 
11:02:43.587 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.415.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96824>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.96824>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.418.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96824>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99251>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.416.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.415.0>
}


11:02:43.587 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.415.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96824>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.96824>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.418.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96824>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99251>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.416.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.415.0>
}


11:02:43.587 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333188.96795>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.415.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.96795>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.96795>},
        pid: #PID<0.415.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.96824>},
        pid: #PID<0.417.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99263>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.416.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.415.0>
}

iex(1)> 
11:02:43.588 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.415.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96824>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.96824>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.418.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96824>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99251>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.416.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.415.0>
}

iex(1)> 
11:02:43.588 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> iex(1)> ** (EXIT from #PID<0.420.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
iex(1)> 
11:02:43.588 [debug] [pipeline@<0.421.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333186.97534>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]


11:02:43.588 [debug] [pipeline@<0.421.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.588 [debug] [pipeline@<0.421.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:43.588 [debug] [pipeline@<0.421.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []


11:02:43.589 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:43.589 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source

11:02:43.589 [debug] [pipeline@<0.421.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink

11:02:43.589 [debug] [pipeline@<0.421.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:43.589 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:43.589 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink

11:02:43.589 [debug] [pipeline@<0.421.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin

11:02:43.589 [debug] [pipeline@<0.421.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []


11:02:43.589 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:43.589 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.589 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:43.589 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []


11:02:43.589 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:43.589 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter

11:02:43.589 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333186.97534>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333186.97534>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333186.97534>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333186.97534>}}], status: :done}]


11:02:43.590 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333186.97534>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.590 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333186.97534>}, module: Membrane.RTP.Parser

11:02:43.590 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333186.97534>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []


11:02:43.590 [debug] [{:rtp_parser, #Reference<0.2271929081.730333186.97534>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:43.590 [debug] [{:rtp_parser, #Reference<0.2271929081.730333186.97534>}] Element initialized: Membrane.RTP.Parser

11:02:43.590 [debug] [pipeline@<0.421.0>] Changing playback state from stopped to prepared

11:02:43.590 [debug] [:rtp bin] Changing playback state from stopped to prepared

11:02:43.591 [debug] [:rtp bin] Playback state changed from stopped to prepared

11:02:43.591 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}


11:02:43.591 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.421.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97534>},
        pid: #PID<0.425.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97536>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.422.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.421.0>
}


11:02:43.591 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.421.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97534>},
        pid: #PID<0.425.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97536>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.422.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.421.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.421.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97534>},
        pid: #PID<0.425.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97536>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.422.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.421.0>
}


11:02:43.591 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.421.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97534>},
        pid: #PID<0.425.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97536>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.422.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.421.0>
}


11:02:43.591 [error] GenServer #PID<0.423.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.421.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333186.97534>}, pid: #PID<0.425.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333186.97536>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.422.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.421.0>}

11:02:43.591 [debug] [pipeline@<0.421.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.

iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.592 [debug] [pipeline@<0.421.0>] A child crashed but was not a member of any crash group.
Terminating.


11:02:43.592 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.421.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97540>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.422.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.421.0>
}


11:02:43.592 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.421.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97540>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.422.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.421.0>
}


11:02:43.592 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.421.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97540>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.422.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.421.0>
}


11:02:43.592 [debug] [{:rtp_parser, #Reference<0.2271929081.730333186.97534>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.425.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333186.97534>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333186.97534>},
        pid: #PID<0.425.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333186.97565>},
        pid: #PID<0.427.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97561>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.426.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.425.0>
}


11:02:43.592 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333186.97534>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.425.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333186.97534>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333186.97534>},
        pid: #PID<0.425.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333186.97565>},
        pid: #PID<0.427.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97561>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.426.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.425.0>
}


11:02:43.593 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333186.97534>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.425.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333186.97534>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333186.97534>},
        pid: #PID<0.425.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333186.97565>},
        pid: #PID<0.427.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97561>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.426.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.425.0>
}


11:02:43.593 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.425.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97565>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333186.97565>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.428.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97565>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97546>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.426.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.425.0>
}


11:02:43.593 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.425.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97565>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333186.97565>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.428.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97565>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97546>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.426.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.425.0>
}


11:02:43.594 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.425.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97565>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333186.97565>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.428.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97565>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97546>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.426.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.425.0>
}

iex(1)> 
11:02:43.670 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:43.670 [debug] [pipeline@<0.431.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333186.97584>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:43.671 [debug] [pipeline@<0.431.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:43.671 [debug] [pipeline@<0.431.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source
iex(1)> 
11:02:43.671 [debug] [pipeline@<0.431.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []

iex(1)> 
11:02:43.671 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}
iex(1)> 
11:02:43.671 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source
iex(1)> 
11:02:43.671 [debug] [pipeline@<0.431.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.671 [debug] [pipeline@<0.431.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []

iex(1)> 
11:02:43.671 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:43.671 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink

11:02:43.671 [debug] [pipeline@<0.431.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin

11:02:43.671 [debug] [pipeline@<0.431.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []


11:02:43.672 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:43.672 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.672 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:43.672 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []


11:02:43.672 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:43.672 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter

11:02:43.672 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333186.97584>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333186.97584>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333186.97584>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333186.97584>}}], status: :done}]


11:02:43.672 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333186.97584>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.672 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333186.97584>}, module: Membrane.RTP.Parser

11:02:43.672 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333186.97584>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []


11:02:43.672 [debug] [{:rtp_parser, #Reference<0.2271929081.730333186.97584>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:43.672 [debug] [{:rtp_parser, #Reference<0.2271929081.730333186.97584>}] Element initialized: Membrane.RTP.Parser
iex(1)> 
11:02:43.673 [debug] [pipeline@<0.431.0>] Changing playback state from stopped to prepared
iex(1)> 
11:02:43.673 [debug] [:rtp bin] Changing playback state from stopped to prepared

11:02:43.673 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}


11:02:43.673 [debug] [:rtp bin] Playback state changed from stopped to prepared

11:02:43.673 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.431.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97584>},
        pid: #PID<0.435.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97586>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.432.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.431.0>
}

iex(1)> iex(1)> 
11:02:43.674 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.431.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97584>},
        pid: #PID<0.435.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97586>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.432.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.431.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.431.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97584>},
        pid: #PID<0.435.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97586>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.432.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.431.0>
}

iex(1)> 
11:02:43.674 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.431.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97584>},
        pid: #PID<0.435.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97586>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.432.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.431.0>
}


11:02:43.674 [error] GenServer #PID<0.433.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.431.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333186.97584>}, pid: #PID<0.435.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333186.97586>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.432.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.431.0>}

11:02:43.675 [debug] [pipeline@<0.431.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.


11:02:43.675 [debug] [pipeline@<0.431.0>] A child crashed but was not a member of any crash group.
Terminating.

iex(1)> ** (EXIT from #PID<0.430.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:43.676 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.435.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96855>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.96855>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.438.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96855>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97596>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.436.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.435.0>
}


11:02:43.676 [debug] [{:rtp_parser, #Reference<0.2271929081.730333186.97584>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.435.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333186.97584>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333186.97584>},
        pid: #PID<0.435.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.96855>},
        pid: #PID<0.437.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97612>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.436.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.435.0>
}

iex(1)> 
11:02:43.675 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.431.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97590>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.432.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.431.0>
}


11:02:43.676 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.435.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96855>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.96855>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.438.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96855>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97596>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.436.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.435.0>
}


11:02:43.676 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333186.97584>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.435.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333186.97584>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333186.97584>},
        pid: #PID<0.435.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.96855>},
        pid: #PID<0.437.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97612>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.436.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.435.0>
}

iex(1)> 
iex(1)> 
11:02:43.677 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.435.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96855>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.96855>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.438.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96855>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97596>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.436.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.435.0>
}


11:02:43.677 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333186.97584>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.435.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333186.97584>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333186.97584>},
        pid: #PID<0.435.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.96855>},
        pid: #PID<0.437.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97612>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.436.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.435.0>
}


11:02:43.677 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.431.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97590>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.432.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.431.0>
}

iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.677 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.431.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97590>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.432.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.431.0>
}

iex(1)> 
11:02:43.681 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:43.681 [debug] [pipeline@<0.441.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333186.97632>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:43.682 [debug] [pipeline@<0.441.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:43.682 [debug] [pipeline@<0.441.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:43.682 [debug] [pipeline@<0.441.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []


11:02:43.682 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:43.682 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source

11:02:43.682 [debug] [pipeline@<0.441.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.682 [debug] [pipeline@<0.441.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []

iex(1)> 
11:02:43.682 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}
iex(1)> 
11:02:43.682 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.682 [debug] [pipeline@<0.441.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin

11:02:43.682 [debug] [pipeline@<0.441.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []

iex(1)> 
11:02:43.682 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []

iex(1)> 
11:02:43.682 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.682 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:43.682 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []


11:02:43.683 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:43.683 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:43.683 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333186.97632>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333186.97632>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333186.97632>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333186.97632>}}], status: :done}]

iex(1)> 
11:02:43.683 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333186.97632>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.683 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333186.97632>}, module: Membrane.RTP.Parser

11:02:43.683 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333186.97632>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []

iex(1)> 
11:02:43.683 [debug] [{:rtp_parser, #Reference<0.2271929081.730333186.97632>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:43.683 [debug] [{:rtp_parser, #Reference<0.2271929081.730333186.97632>}] Element initialized: Membrane.RTP.Parser
iex(1)> 
11:02:43.684 [debug] [pipeline@<0.441.0>] Changing playback state from stopped to prepared
iex(1)> iex(1)> 
11:02:43.684 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> 
11:02:43.684 [debug] [:rtp bin] Playback state changed from stopped to prepared
iex(1)> 
11:02:43.684 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> 
11:02:43.685 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.441.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97632>},
        pid: #PID<0.445.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97634>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.442.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.441.0>
}

iex(1)> 
11:02:43.685 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.441.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97632>},
        pid: #PID<0.445.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97634>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.442.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.441.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.441.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97632>},
        pid: #PID<0.445.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97634>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.442.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.441.0>
}

iex(1)> 
11:02:43.686 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.441.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97632>},
        pid: #PID<0.445.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97634>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.442.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.441.0>
}


11:02:43.686 [error] GenServer #PID<0.443.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.441.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333186.97632>}, pid: #PID<0.445.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333186.97634>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.442.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.441.0>}

11:02:43.686 [debug] [pipeline@<0.441.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.


11:02:43.686 [debug] [pipeline@<0.441.0>] A child crashed but was not a member of any crash group.
Terminating.

iex(1)> ** (EXIT from #PID<0.440.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.687 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.441.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97638>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.442.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.441.0>
}

iex(1)> 
11:02:43.687 [debug] [{:rtp_parser, #Reference<0.2271929081.730333186.97632>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.445.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333186.97632>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333186.97632>},
        pid: #PID<0.445.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99326>},
        pid: #PID<0.447.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99321>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.446.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.445.0>
}


11:02:43.687 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.441.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97638>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.442.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.441.0>
}


11:02:43.687 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.441.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97638>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.442.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.441.0>
}


11:02:43.687 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333186.97632>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.445.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333186.97632>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333186.97632>},
        pid: #PID<0.445.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99326>},
        pid: #PID<0.447.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99321>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.446.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.445.0>
}


11:02:43.688 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333186.97632>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.445.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333186.97632>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333186.97632>},
        pid: #PID<0.445.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99326>},
        pid: #PID<0.447.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99321>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.446.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.445.0>
}


11:02:43.688 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.445.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99326>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99326>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.448.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99326>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99304>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.446.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.445.0>
}


11:02:43.688 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.445.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99326>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99326>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.448.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99326>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99304>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.446.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.445.0>
}


11:02:43.688 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.445.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99326>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99326>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.448.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99326>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99304>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.446.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.445.0>
}

iex(1)> 
11:02:43.689 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> iex(1)> ** (EXIT from #PID<0.450.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:43.689 [debug] [pipeline@<0.451.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106791>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]


11:02:43.689 [debug] [pipeline@<0.451.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.689 [debug] [pipeline@<0.451.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:43.689 [debug] [pipeline@<0.451.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []


11:02:43.689 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:43.690 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source

11:02:43.690 [debug] [pipeline@<0.451.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink

11:02:43.690 [debug] [pipeline@<0.451.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:43.690 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:43.690 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink

11:02:43.690 [debug] [pipeline@<0.451.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin

11:02:43.690 [debug] [pipeline@<0.451.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []


11:02:43.690 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:43.690 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.690 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:43.690 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []


11:02:43.690 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:43.690 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter

11:02:43.690 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333185.106791>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333185.106791>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106791>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333185.106791>}}], status: :done}]


11:02:43.691 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333185.106791>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.691 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333185.106791>}, module: Membrane.RTP.Parser

11:02:43.691 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333185.106791>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []


11:02:43.691 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106791>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:43.691 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106791>}] Element initialized: Membrane.RTP.Parser

11:02:43.691 [debug] [pipeline@<0.451.0>] Changing playback state from stopped to prepared

11:02:43.691 [debug] [:rtp bin] Changing playback state from stopped to prepared

11:02:43.691 [debug] [:rtp bin] Playback state changed from stopped to prepared

11:02:43.691 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}


11:02:43.691 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.451.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106791>},
        pid: #PID<0.455.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106793>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.452.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.451.0>
}


11:02:43.692 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.451.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106791>},
        pid: #PID<0.455.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106793>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.452.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.451.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.451.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106791>},
        pid: #PID<0.455.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106793>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.452.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.451.0>
}


11:02:43.692 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.451.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106791>},
        pid: #PID<0.455.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106793>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.452.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.451.0>
}


11:02:43.692 [error] GenServer #PID<0.453.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.451.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106791>}, pid: #PID<0.455.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333185.106793>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.452.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.451.0>}

11:02:43.692 [debug] [pipeline@<0.451.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.

iex(1)> 
iex(1)> 
11:02:43.693 [debug] [pipeline@<0.451.0>] A child crashed but was not a member of any crash group.
Terminating.


11:02:43.693 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.451.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106797>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.452.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.451.0>
}


11:02:43.693 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.451.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106797>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.452.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.451.0>
}


11:02:43.693 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.451.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106797>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.452.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.451.0>
}


11:02:43.693 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106791>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.455.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.106791>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.106791>},
        pid: #PID<0.455.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333186.97661>},
        pid: #PID<0.457.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97657>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.456.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.455.0>
}


11:02:43.694 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333185.106791>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.455.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.106791>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.106791>},
        pid: #PID<0.455.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333186.97661>},
        pid: #PID<0.457.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97657>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.456.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.455.0>
}


11:02:43.694 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333185.106791>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.455.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.106791>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.106791>},
        pid: #PID<0.455.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333186.97661>},
        pid: #PID<0.457.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97657>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.456.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.455.0>
}


11:02:43.695 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.455.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97661>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333186.97661>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.458.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97661>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106803>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.456.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.455.0>
}


11:02:43.696 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.455.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97661>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333186.97661>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.458.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97661>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106803>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.456.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.455.0>
}


11:02:43.696 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.455.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97661>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333186.97661>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.458.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97661>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106803>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.456.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.455.0>
}

iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.777 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:43.778 [debug] [pipeline@<0.461.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106832>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]


11:02:43.778 [debug] [pipeline@<0.461.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.778 [debug] [pipeline@<0.461.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:43.778 [debug] [pipeline@<0.461.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []


11:02:43.778 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:43.778 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source

11:02:43.778 [debug] [pipeline@<0.461.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink

11:02:43.778 [debug] [pipeline@<0.461.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []

iex(1)> 
11:02:43.779 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}
iex(1)> 
11:02:43.779 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.779 [debug] [pipeline@<0.461.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin
iex(1)> 
11:02:43.779 [debug] [pipeline@<0.461.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []

iex(1)> 
11:02:43.780 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []

iex(1)> 
11:02:43.780 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:43.780 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:43.780 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []

iex(1)> 
11:02:43.780 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil
iex(1)> 
11:02:43.780 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:43.780 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333185.106832>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333185.106832>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106832>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333185.106832>}}], status: :done}]

iex(1)> 
11:02:43.780 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333185.106832>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:43.780 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333185.106832>}, module: Membrane.RTP.Parser
iex(1)> 
11:02:43.780 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333185.106832>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []

iex(1)> 
11:02:43.780 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106832>}] Initializing element: Membrane.RTP.Parser, options: nil
iex(1)> 
11:02:43.780 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106832>}] Element initialized: Membrane.RTP.Parser
iex(1)> 
11:02:43.781 [debug] [pipeline@<0.461.0>] Changing playback state from stopped to prepared
iex(1)> 
11:02:43.781 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> 
11:02:43.781 [debug] [:rtp bin] Playback state changed from stopped to prepared
iex(1)> iex(1)> 
11:02:43.781 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> 
11:02:43.781 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.461.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106832>},
        pid: #PID<0.465.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106834>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.462.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.461.0>
}

iex(1)> 
11:02:43.781 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.461.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106832>},
        pid: #PID<0.465.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106834>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.462.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.461.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.461.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106832>},
        pid: #PID<0.465.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106834>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.462.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.461.0>
}

iex(1)> 
11:02:43.782 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.461.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106832>},
        pid: #PID<0.465.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106834>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.462.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.461.0>
}

iex(1)> 
11:02:43.782 [error] GenServer #PID<0.463.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.461.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106832>}, pid: #PID<0.465.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333185.106834>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.462.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.461.0>}

11:02:43.782 [debug] [pipeline@<0.461.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.


11:02:43.782 [debug] [pipeline@<0.461.0>] A child crashed but was not a member of any crash group.
Terminating.

iex(1)> 
11:02:43.782 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.461.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97670>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.462.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.461.0>
}

iex(1)> 
11:02:43.782 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.461.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97670>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.462.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.461.0>
}

iex(1)> 
11:02:43.783 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.461.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97670>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.462.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.461.0>
}

iex(1)> ** (EXIT from #PID<0.460.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.783 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106832>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.465.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.106832>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.106832>},
        pid: #PID<0.465.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.106854>},
        pid: #PID<0.467.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97693>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.466.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.465.0>
}

iex(1)> 
11:02:43.784 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333185.106832>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.465.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.106832>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.106832>},
        pid: #PID<0.465.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.106854>},
        pid: #PID<0.467.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97693>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.466.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.465.0>
}

iex(1)> 
11:02:43.784 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.465.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106854>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.106854>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.468.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106854>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97680>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.466.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.465.0>
}

iex(1)> 
11:02:43.784 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333185.106832>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.465.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.106832>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.106832>},
        pid: #PID<0.465.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.106854>},
        pid: #PID<0.467.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97693>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.466.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.465.0>
}

iex(1)> 
11:02:43.784 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.465.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106854>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.106854>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.468.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106854>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97680>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.466.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.465.0>
}

iex(1)> 
11:02:43.785 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.465.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106854>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.106854>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.468.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106854>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97680>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.466.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.465.0>
}

iex(1)> 
11:02:43.785 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:43.785 [debug] [pipeline@<0.471.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333186.97722>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]


11:02:43.785 [debug] [pipeline@<0.471.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.785 [debug] [pipeline@<0.471.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:43.785 [debug] [pipeline@<0.471.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []


11:02:43.785 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:43.785 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source

11:02:43.785 [debug] [pipeline@<0.471.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink

11:02:43.786 [debug] [pipeline@<0.471.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:43.786 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:43.786 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink

11:02:43.786 [debug] [pipeline@<0.471.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin

11:02:43.786 [debug] [pipeline@<0.471.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []


11:02:43.786 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:43.786 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.786 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:43.786 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []


11:02:43.786 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:43.786 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter

11:02:43.786 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333186.97722>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333186.97722>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333186.97722>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333186.97722>}}], status: :done}]


11:02:43.786 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333186.97722>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.786 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333186.97722>}, module: Membrane.RTP.Parser

11:02:43.786 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333186.97722>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []


11:02:43.786 [debug] [{:rtp_parser, #Reference<0.2271929081.730333186.97722>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:43.786 [debug] [{:rtp_parser, #Reference<0.2271929081.730333186.97722>}] Element initialized: Membrane.RTP.Parser

11:02:43.786 [debug] [pipeline@<0.471.0>] Changing playback state from stopped to prepared
iex(1)> iex(1)> 
11:02:43.787 [debug] [:rtp bin] Changing playback state from stopped to prepared

11:02:43.787 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> 
11:02:43.787 [debug] [:rtp bin] Playback state changed from stopped to prepared
iex(1)> 
11:02:43.787 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.471.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97722>},
        pid: #PID<0.475.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97724>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.472.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.471.0>
}

iex(1)> 
11:02:43.787 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.471.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97722>},
        pid: #PID<0.475.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97724>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.472.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.471.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.471.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97722>},
        pid: #PID<0.475.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97724>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.472.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.471.0>
}

iex(1)> 
11:02:43.788 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.471.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333186.97722>},
        pid: #PID<0.475.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97724>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.472.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.471.0>
}

iex(1)> 
11:02:43.788 [error] GenServer #PID<0.473.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.471.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333186.97722>}, pid: #PID<0.475.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333186.97724>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.472.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.471.0>}
iex(1)> 
11:02:43.788 [debug] [pipeline@<0.471.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.

iex(1)> ** (EXIT from #PID<0.470.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.788 [debug] [pipeline@<0.471.0>] A child crashed but was not a member of any crash group.
Terminating.


11:02:43.788 [debug] [{:rtp_parser, #Reference<0.2271929081.730333186.97722>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.475.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333186.97722>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333186.97722>},
        pid: #PID<0.475.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333186.97755>},
        pid: #PID<0.477.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97751>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.476.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.475.0>
}


11:02:43.788 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.471.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97728>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.472.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.471.0>
}


11:02:43.789 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.475.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97755>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333186.97755>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.478.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97755>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97734>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.476.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.475.0>
}


11:02:43.789 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333186.97722>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.475.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333186.97722>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333186.97722>},
        pid: #PID<0.475.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333186.97755>},
        pid: #PID<0.477.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97751>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.476.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.475.0>
}


11:02:43.789 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.471.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97728>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.472.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.471.0>
}


11:02:43.789 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333186.97722>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.475.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333186.97722>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333186.97722>},
        pid: #PID<0.475.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333186.97755>},
        pid: #PID<0.477.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97751>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.476.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.475.0>
}


11:02:43.789 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.471.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97728>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.472.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.471.0>
}


11:02:43.789 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.475.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97755>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333186.97755>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.478.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97755>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97734>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.476.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.475.0>
}


11:02:43.790 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.475.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97755>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333186.97755>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.478.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97755>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97734>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.476.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.475.0>
}

iex(1)> 
11:02:43.898 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:43.898 [debug] [pipeline@<0.481.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106884>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:43.898 [debug] [pipeline@<0.481.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:43.898 [debug] [pipeline@<0.481.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:43.898 [debug] [pipeline@<0.481.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []

iex(1)> 
11:02:43.898 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:43.898 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source
iex(1)> 
11:02:43.898 [debug] [pipeline@<0.481.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.898 [debug] [pipeline@<0.481.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:43.898 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:43.898 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.898 [debug] [pipeline@<0.481.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin
iex(1)> 
11:02:43.898 [debug] [pipeline@<0.481.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []

iex(1)> 
11:02:43.899 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:43.899 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.899 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:43.899 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []

iex(1)> 
11:02:43.899 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:43.899 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:43.899 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333185.106884>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333185.106884>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106884>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333185.106884>}}], status: :done}]

iex(1)> 
11:02:43.899 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333185.106884>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.899 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333185.106884>}, module: Membrane.RTP.Parser

11:02:43.899 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333185.106884>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []

iex(1)> 
11:02:43.899 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106884>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:43.899 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106884>}] Element initialized: Membrane.RTP.Parser
iex(1)> 
11:02:43.899 [debug] [pipeline@<0.481.0>] Changing playback state from stopped to prepared
iex(1)> 
11:02:43.899 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> iex(1)> 
11:02:43.899 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> 
11:02:43.900 [debug] [:rtp bin] Playback state changed from stopped to prepared

11:02:43.900 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.481.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106884>},
        pid: #PID<0.485.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106889>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.482.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.481.0>
}

iex(1)> 
11:02:43.900 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.481.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106884>},
        pid: #PID<0.485.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106889>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.482.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.481.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.481.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106884>},
        pid: #PID<0.485.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106889>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.482.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.481.0>
}

iex(1)> 
11:02:43.900 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.481.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106884>},
        pid: #PID<0.485.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106889>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.482.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.481.0>
}


11:02:43.900 [error] GenServer #PID<0.483.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.481.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106884>}, pid: #PID<0.485.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333185.106889>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.482.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.481.0>}

11:02:43.901 [debug] [pipeline@<0.481.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.


11:02:43.901 [debug] [pipeline@<0.481.0>] A child crashed but was not a member of any crash group.
Terminating.

iex(1)> ** (EXIT from #PID<0.480.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:43.901 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.481.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106895>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.482.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.481.0>
}

iex(1)> 
iex(1)> 
11:02:43.902 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.485.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106928>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.106928>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.488.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106928>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106905>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.486.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.485.0>
}


11:02:43.902 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106884>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.485.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.106884>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.106884>},
        pid: #PID<0.485.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.106928>},
        pid: #PID<0.487.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106923>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.486.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.485.0>
}

iex(1)> 
11:02:43.902 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.481.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106895>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.482.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.481.0>
}


11:02:43.902 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.481.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106895>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.482.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.481.0>
}


11:02:43.902 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.485.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106928>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.106928>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.488.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106928>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106905>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.486.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.485.0>
}


11:02:43.902 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333185.106884>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.485.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.106884>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.106884>},
        pid: #PID<0.485.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.106928>},
        pid: #PID<0.487.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106923>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.486.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.485.0>
}


11:02:43.903 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.485.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106928>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.106928>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.488.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.106928>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106905>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.486.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.485.0>
}


11:02:43.903 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333185.106884>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.485.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.106884>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.106884>},
        pid: #PID<0.485.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.106928>},
        pid: #PID<0.487.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106923>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.486.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.485.0>
}

iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.920 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:43.920 [debug] [pipeline@<0.491.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106962>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:43.920 [debug] [pipeline@<0.491.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:43.920 [debug] [pipeline@<0.491.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:43.920 [debug] [pipeline@<0.491.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []

iex(1)> 
11:02:43.920 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:43.920 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source
iex(1)> 
11:02:43.920 [debug] [pipeline@<0.491.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.920 [debug] [pipeline@<0.491.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:43.920 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:43.920 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.920 [debug] [pipeline@<0.491.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin
iex(1)> 
11:02:43.921 [debug] [pipeline@<0.491.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []

iex(1)> 
11:02:43.921 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:43.921 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.921 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:43.921 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []

iex(1)> 
11:02:43.921 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:43.921 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:43.921 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333185.106962>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333185.106962>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106962>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333185.106962>}}], status: :done}]

iex(1)> 
11:02:43.921 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333185.106962>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.921 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333185.106962>}, module: Membrane.RTP.Parser

11:02:43.921 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333185.106962>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []

iex(1)> 
11:02:43.921 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106962>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:43.921 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106962>}] Element initialized: Membrane.RTP.Parser
iex(1)> 
11:02:43.921 [debug] [pipeline@<0.491.0>] Changing playback state from stopped to prepared
iex(1)> 
11:02:43.921 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> iex(1)> 
11:02:43.921 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> 
11:02:43.922 [debug] [:rtp bin] Playback state changed from stopped to prepared

11:02:43.922 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.491.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106962>},
        pid: #PID<0.495.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106967>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.492.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.491.0>
}

iex(1)> 
11:02:43.922 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.491.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106962>},
        pid: #PID<0.495.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106967>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.492.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.491.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.491.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106962>},
        pid: #PID<0.495.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106967>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.492.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.491.0>
}

iex(1)> ** (EXIT from #PID<0.490.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:43.922 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.491.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.106962>},
        pid: #PID<0.495.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.106967>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.492.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.491.0>
}


11:02:43.922 [error] GenServer #PID<0.493.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.491.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.106962>}, pid: #PID<0.495.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333185.106967>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.492.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.491.0>}

11:02:43.922 [debug] [pipeline@<0.491.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.


11:02:43.923 [debug] [pipeline@<0.491.0>] A child crashed but was not a member of any crash group.
Terminating.

iex(1)> 
iex(1)> 
11:02:43.923 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.491.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106973>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.492.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.491.0>
}


11:02:43.923 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.495.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107006>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.107006>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.498.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107006>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106983>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.496.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.495.0>
}


11:02:43.924 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.106962>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.495.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.106962>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.106962>},
        pid: #PID<0.495.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.107006>},
        pid: #PID<0.497.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.107001>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.496.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.495.0>
}

iex(1)> 
11:02:43.924 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.491.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106973>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.492.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.491.0>
}

iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.924 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.491.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106973>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.492.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.491.0>
}


11:02:43.924 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.495.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107006>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.107006>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.498.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107006>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106983>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.496.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.495.0>
}


11:02:43.924 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333185.106962>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.495.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.106962>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.106962>},
        pid: #PID<0.495.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.107006>},
        pid: #PID<0.497.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.107001>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.496.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.495.0>
}


11:02:43.925 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.495.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107006>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.107006>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.498.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107006>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.106983>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.496.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.495.0>
}


11:02:43.925 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333185.106962>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.495.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.106962>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.106962>},
        pid: #PID<0.495.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.107006>},
        pid: #PID<0.497.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.107001>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.496.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.495.0>
}

iex(1)> 
11:02:43.928 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:43.928 [debug] [pipeline@<0.501.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.107040>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:43.929 [debug] [pipeline@<0.501.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:43.929 [debug] [pipeline@<0.501.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:43.929 [debug] [pipeline@<0.501.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []

iex(1)> 
11:02:43.929 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:43.929 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source
iex(1)> 
11:02:43.929 [debug] [pipeline@<0.501.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.930 [debug] [pipeline@<0.501.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:43.930 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:43.930 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.930 [debug] [pipeline@<0.501.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin
iex(1)> 
11:02:43.930 [debug] [pipeline@<0.501.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []

iex(1)> 
11:02:43.930 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:43.930 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.930 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:43.930 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []

iex(1)> 
11:02:43.930 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:43.930 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:43.931 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333185.107040>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333185.107040>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.107040>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333185.107040>}}], status: :done}]

iex(1)> 
11:02:43.931 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333185.107040>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:43.931 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333185.107040>}, module: Membrane.RTP.Parser

11:02:43.931 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333185.107040>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []

iex(1)> 
11:02:43.931 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.107040>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:43.931 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.107040>}] Element initialized: Membrane.RTP.Parser
iex(1)> 
11:02:43.931 [debug] [pipeline@<0.501.0>] Changing playback state from stopped to prepared
iex(1)> 
11:02:43.932 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> iex(1)> 
11:02:43.932 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> 
11:02:43.932 [debug] [:rtp bin] Playback state changed from stopped to prepared

11:02:43.932 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.501.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.107040>},
        pid: #PID<0.505.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.107045>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.502.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.501.0>
}

iex(1)> 
11:02:43.933 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.501.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.107040>},
        pid: #PID<0.505.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.107045>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.502.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.501.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.501.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.107040>},
        pid: #PID<0.505.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.107045>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.502.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.501.0>
}

iex(1)> 
11:02:43.933 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.501.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333185.107040>},
        pid: #PID<0.505.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.107045>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.502.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.501.0>
}

iex(1)> 
11:02:43.933 [error] GenServer #PID<0.503.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.501.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333185.107040>}, pid: #PID<0.505.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333185.107045>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.502.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.501.0>}
iex(1)> 
11:02:43.933 [debug] [pipeline@<0.501.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.


11:02:43.933 [debug] [pipeline@<0.501.0>] A child crashed but was not a member of any crash group.
Terminating.

iex(1)> ** (EXIT from #PID<0.500.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:43.933 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.501.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.107051>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.502.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.501.0>
}


11:02:43.934 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.505.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107084>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.107084>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.508.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107084>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.107061>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.506.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.505.0>
}


11:02:43.934 [debug] [{:rtp_parser, #Reference<0.2271929081.730333185.107040>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.505.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.107040>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.107040>},
        pid: #PID<0.505.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.107084>},
        pid: #PID<0.507.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.107079>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.506.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.505.0>
}

iex(1)> 
iex(1)> 
11:02:43.934 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.501.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.107051>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.502.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.501.0>
}


11:02:43.934 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333185.107040>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.505.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.107040>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.107040>},
        pid: #PID<0.505.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.107084>},
        pid: #PID<0.507.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.107079>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.506.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.505.0>
}


11:02:43.935 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.501.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.107051>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.502.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.501.0>
}


11:02:43.935 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.505.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107084>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.107084>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.508.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107084>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.107061>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.506.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.505.0>
}


11:02:43.935 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333185.107040>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.505.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333185.107040>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333185.107040>},
        pid: #PID<0.505.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.107084>},
        pid: #PID<0.507.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333185.107079>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.506.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.505.0>
}

iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.935 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.505.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107084>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.107084>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.508.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107084>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333185.107061>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.506.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.505.0>
}

iex(1)> 
11:02:43.936 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:43.936 [debug] [pipeline@<0.511.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.96876>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:43.936 [debug] [pipeline@<0.511.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:43.936 [debug] [pipeline@<0.511.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:43.936 [debug] [pipeline@<0.511.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []

iex(1)> 
11:02:43.936 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}
iex(1)> 
11:02:43.936 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source
iex(1)> 
11:02:43.936 [debug] [pipeline@<0.511.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.936 [debug] [pipeline@<0.511.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []

iex(1)> 
11:02:43.936 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}
iex(1)> 
11:02:43.936 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:43.936 [debug] [pipeline@<0.511.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin
iex(1)> 
11:02:43.937 [debug] [pipeline@<0.511.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []

iex(1)> 
11:02:43.937 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []

iex(1)> 
11:02:43.937 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:43.937 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:43.937 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []

iex(1)> 
11:02:43.937 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil
iex(1)> 
11:02:43.937 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:43.937 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333188.96876>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333188.96876>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.96876>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333188.96876>}}], status: :done}]

iex(1)> 
11:02:43.937 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333188.96876>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:43.937 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333188.96876>}, module: Membrane.RTP.Parser
iex(1)> 
11:02:43.937 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333188.96876>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []

iex(1)> 
11:02:43.937 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.96876>}] Initializing element: Membrane.RTP.Parser, options: nil
iex(1)> 
11:02:43.937 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.96876>}] Element initialized: Membrane.RTP.Parser
iex(1)> 
11:02:43.938 [debug] [pipeline@<0.511.0>] Changing playback state from stopped to prepared
iex(1)> 
11:02:43.938 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> 
11:02:43.938 [debug] [:rtp bin] Playback state changed from stopped to prepared
iex(1)> iex(1)> 
11:02:43.938 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> 
11:02:43.938 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.511.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.96876>},
        pid: #PID<0.515.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96878>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.512.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.511.0>
}

iex(1)> 
11:02:43.938 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.511.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.96876>},
        pid: #PID<0.515.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96878>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.512.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.511.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.511.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.96876>},
        pid: #PID<0.515.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96878>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.512.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.511.0>
}

iex(1)> 
11:02:43.939 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.511.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.96876>},
        pid: #PID<0.515.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96878>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.512.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.511.0>
}

iex(1)> ** (EXIT from #PID<0.510.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:43.939 [error] GenServer #PID<0.513.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.511.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.96876>}, pid: #PID<0.515.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333188.96878>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.512.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.511.0>}

11:02:43.939 [debug] [pipeline@<0.511.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.


11:02:43.939 [debug] [pipeline@<0.511.0>] A child crashed but was not a member of any crash group.
Terminating.


11:02:43.939 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.96876>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.515.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.96876>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.96876>},
        pid: #PID<0.515.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.96899>},
        pid: #PID<0.517.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96895>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.516.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.515.0>
}


11:02:43.939 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.511.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97781>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.512.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.511.0>
}


11:02:43.940 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.515.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96899>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.96899>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.518.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96899>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97787>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.516.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.515.0>
}


11:02:43.940 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333188.96876>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.515.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.96876>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.96876>},
        pid: #PID<0.515.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.96899>},
        pid: #PID<0.517.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96895>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.516.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.515.0>
}


11:02:43.940 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.511.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97781>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.512.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.511.0>
}


11:02:43.940 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333188.96876>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.515.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.96876>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.96876>},
        pid: #PID<0.515.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.96899>},
        pid: #PID<0.517.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96895>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.516.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.515.0>
}


11:02:43.940 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.511.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97781>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.512.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.511.0>
}


11:02:43.941 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.515.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96899>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.96899>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.518.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96899>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97787>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.516.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.515.0>
}


11:02:43.941 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.515.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96899>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.96899>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.518.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.96899>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97787>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.516.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.515.0>
}

iex(1)> 
11:02:44.012 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:44.012 [debug] [pipeline@<0.521.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.96913>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:44.013 [debug] [pipeline@<0.521.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:44.013 [debug] [pipeline@<0.521.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source
iex(1)> 
11:02:44.013 [debug] [pipeline@<0.521.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []

iex(1)> 
11:02:44.013 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:44.013 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source
iex(1)> 
11:02:44.013 [debug] [pipeline@<0.521.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:44.013 [debug] [pipeline@<0.521.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:44.013 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:44.013 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:44.013 [debug] [pipeline@<0.521.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin
iex(1)> 
11:02:44.013 [debug] [pipeline@<0.521.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []

iex(1)> 
11:02:44.013 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:44.013 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:44.013 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:44.013 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []

iex(1)> 
11:02:44.013 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:44.014 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:44.014 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333188.96913>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333188.96913>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.96913>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333188.96913>}}], status: :done}]

iex(1)> 
11:02:44.014 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333188.96913>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:44.014 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333188.96913>}, module: Membrane.RTP.Parser
iex(1)> 
11:02:44.014 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333188.96913>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []

iex(1)> 
11:02:44.014 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.96913>}] Initializing element: Membrane.RTP.Parser, options: nil
iex(1)> 
11:02:44.014 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.96913>}] Element initialized: Membrane.RTP.Parser
iex(1)> 
11:02:44.014 [debug] [pipeline@<0.521.0>] Changing playback state from stopped to prepared
iex(1)> iex(1)> 
11:02:44.014 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> 
11:02:44.014 [debug] [:rtp bin] Playback state changed from stopped to prepared
iex(1)> 
11:02:44.014 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> 
11:02:44.015 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.521.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.96913>},
        pid: #PID<0.525.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96918>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.522.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.521.0>
}

iex(1)> 
11:02:44.015 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.521.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.96913>},
        pid: #PID<0.525.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96918>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.522.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.521.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.521.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.96913>},
        pid: #PID<0.525.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96918>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.522.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.521.0>
}


11:02:44.015 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.521.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.96913>},
        pid: #PID<0.525.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96918>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.522.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.521.0>
}


11:02:44.015 [error] GenServer #PID<0.523.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.521.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.96913>}, pid: #PID<0.525.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333188.96918>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.522.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.521.0>}

11:02:44.015 [debug] [pipeline@<0.521.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.


11:02:44.015 [debug] [pipeline@<0.521.0>] A child crashed but was not a member of any crash group.
Terminating.


11:02:44.015 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.521.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96924>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.522.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.521.0>
}


11:02:44.016 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.521.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96924>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.522.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.521.0>
}


11:02:44.016 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.521.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96924>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.522.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.521.0>
}

iex(1)> ** (EXIT from #PID<0.520.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:44.016 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.525.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99357>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99357>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.528.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99357>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96934>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.526.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.525.0>
}

iex(1)> 
11:02:44.016 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.525.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99357>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99357>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.528.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99357>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96934>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.526.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.525.0>
}


11:02:44.017 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.525.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99357>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99357>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.528.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99357>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96934>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.526.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.525.0>
}


11:02:44.017 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.96913>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.525.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.96913>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.96913>},
        pid: #PID<0.525.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99357>},
        pid: #PID<0.527.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99353>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.526.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.525.0>
}


11:02:44.017 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333188.96913>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.525.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.96913>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.96913>},
        pid: #PID<0.525.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99357>},
        pid: #PID<0.527.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99353>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.526.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.525.0>
}

iex(1)> 
iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:44.017 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333188.96913>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.525.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.96913>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.96913>},
        pid: #PID<0.525.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99357>},
        pid: #PID<0.527.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99353>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.526.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.525.0>
}

iex(1)> 
11:02:44.018 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:44.018 [debug] [pipeline@<0.531.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.96973>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:44.018 [debug] [pipeline@<0.531.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:44.018 [debug] [pipeline@<0.531.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:44.018 [debug] [pipeline@<0.531.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []


11:02:44.018 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:44.018 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source
iex(1)> 
11:02:44.018 [debug] [pipeline@<0.531.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:44.018 [debug] [pipeline@<0.531.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []

iex(1)> 
11:02:44.019 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}
iex(1)> 
11:02:44.019 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:44.019 [debug] [pipeline@<0.531.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin
iex(1)> 
11:02:44.019 [debug] [pipeline@<0.531.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []

iex(1)> 
11:02:44.019 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []

iex(1)> 
11:02:44.019 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:44.019 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:44.019 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []

iex(1)> 
11:02:44.019 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil
iex(1)> 
11:02:44.019 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:44.019 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333188.96973>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333188.96973>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.96973>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333188.96973>}}], status: :done}]

iex(1)> 
11:02:44.019 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333188.96973>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:44.019 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333188.96973>}, module: Membrane.RTP.Parser
iex(1)> 
11:02:44.019 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333188.96973>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []

iex(1)> 
11:02:44.019 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.96973>}] Initializing element: Membrane.RTP.Parser, options: nil
iex(1)> 
11:02:44.020 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.96973>}] Element initialized: Membrane.RTP.Parser
iex(1)> 
11:02:44.020 [debug] [pipeline@<0.531.0>] Changing playback state from stopped to prepared
iex(1)> 
11:02:44.020 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> iex(1)> 
11:02:44.020 [debug] [:rtp bin] Playback state changed from stopped to prepared
iex(1)> 
11:02:44.020 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> 
11:02:44.020 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.531.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.96973>},
        pid: #PID<0.535.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96976>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.532.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.531.0>
}

iex(1)> 
11:02:44.021 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.531.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.96973>},
        pid: #PID<0.535.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96976>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.532.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.531.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.531.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.96973>},
        pid: #PID<0.535.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96976>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.532.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.531.0>
}

iex(1)> 
11:02:44.021 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.531.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.96973>},
        pid: #PID<0.535.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96976>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.532.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.531.0>
}

iex(1)> 
11:02:44.021 [error] GenServer #PID<0.533.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.531.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.96973>}, pid: #PID<0.535.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333188.96976>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.532.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.531.0>}
iex(1)> 
11:02:44.021 [debug] [pipeline@<0.531.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.

iex(1)> 
11:02:44.021 [debug] [pipeline@<0.531.0>] A child crashed but was not a member of any crash group.
Terminating.

iex(1)> 
11:02:44.022 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.535.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.97003>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.97003>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.538.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.97003>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96986>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.536.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.535.0>
}

iex(1)> 
11:02:44.022 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.96973>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.535.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.96973>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.96973>},
        pid: #PID<0.535.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.97003>},
        pid: #PID<0.537.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96999>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.536.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.535.0>
}

iex(1)> 
11:02:44.022 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.535.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.97003>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.97003>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.538.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.97003>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96986>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.536.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.535.0>
}


11:02:44.022 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333188.96973>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.535.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.96973>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.96973>},
        pid: #PID<0.535.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.97003>},
        pid: #PID<0.537.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96999>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.536.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.535.0>
}

iex(1)> ** (EXIT from #PID<0.530.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:44.022 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333188.96973>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.535.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.96973>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.96973>},
        pid: #PID<0.535.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.97003>},
        pid: #PID<0.537.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.96999>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.536.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.535.0>
}

iex(1)> 
iex(1)> 
11:02:44.023 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.535.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.97003>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.97003>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.538.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.97003>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96986>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.536.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.535.0>
}


11:02:44.023 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.531.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96980>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.532.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.531.0>
}


11:02:44.023 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.531.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96980>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.532.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.531.0>
}


11:02:44.023 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.531.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.96980>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.532.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.531.0>
}

iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:44.024 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:44.024 [debug] [pipeline@<0.541.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.97011>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:44.024 [debug] [pipeline@<0.541.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> iex(1)> ** (EXIT from #PID<0.540.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:44.024 [debug] [pipeline@<0.541.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:44.024 [debug] [pipeline@<0.541.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []


11:02:44.024 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:44.024 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source

11:02:44.024 [debug] [pipeline@<0.541.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink

11:02:44.024 [debug] [pipeline@<0.541.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:44.024 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:44.024 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink

11:02:44.024 [debug] [pipeline@<0.541.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin

11:02:44.024 [debug] [pipeline@<0.541.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []


11:02:44.024 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:44.025 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:44.025 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:44.025 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []


11:02:44.025 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:44.025 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter

11:02:44.025 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333188.97011>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333188.97011>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.97011>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333188.97011>}}], status: :done}]


11:02:44.025 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333188.97011>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:44.025 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333188.97011>}, module: Membrane.RTP.Parser

11:02:44.025 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333188.97011>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []


11:02:44.025 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.97011>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:44.025 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.97011>}] Element initialized: Membrane.RTP.Parser

11:02:44.025 [debug] [pipeline@<0.541.0>] Changing playback state from stopped to prepared

11:02:44.025 [debug] [:rtp bin] Changing playback state from stopped to prepared

11:02:44.025 [debug] [:rtp bin] Playback state changed from stopped to prepared

11:02:44.025 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}


11:02:44.026 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.541.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.97011>},
        pid: #PID<0.545.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97013>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.542.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.541.0>
}


11:02:44.026 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.541.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.97011>},
        pid: #PID<0.545.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97013>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.542.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.541.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.541.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.97011>},
        pid: #PID<0.545.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97013>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.542.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.541.0>
}


11:02:44.026 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.541.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.97011>},
        pid: #PID<0.545.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97013>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.542.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.541.0>
}


11:02:44.026 [error] GenServer #PID<0.543.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.541.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.97011>}, pid: #PID<0.545.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333188.97013>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.542.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.541.0>}

11:02:44.027 [debug] [pipeline@<0.541.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.


11:02:44.027 [debug] [pipeline@<0.541.0>] A child crashed but was not a member of any crash group.
Terminating.


11:02:44.027 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.545.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107122>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.107122>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.548.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107122>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.97023>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.546.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.545.0>
}

iex(1)> 
11:02:44.027 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.541.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.97017>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.542.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.541.0>
}


11:02:44.027 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.545.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107122>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.107122>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.548.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107122>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.97023>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.546.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.545.0>
}


11:02:44.027 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.97011>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.545.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.97011>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.97011>},
        pid: #PID<0.545.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.107122>},
        pid: #PID<0.547.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97038>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.546.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.545.0>
}


11:02:44.027 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.541.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.97017>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.542.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.541.0>
}


11:02:44.028 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.541.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.97017>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.542.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.541.0>
}


11:02:44.028 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333188.97011>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.545.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.97011>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.97011>},
        pid: #PID<0.545.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.107122>},
        pid: #PID<0.547.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97038>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.546.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.545.0>
}


11:02:44.028 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333188.97011>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.545.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.97011>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.97011>},
        pid: #PID<0.545.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.107122>},
        pid: #PID<0.547.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97038>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.546.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.545.0>
}


11:02:44.028 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.545.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107122>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.107122>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.548.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107122>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.97023>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.546.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.545.0>
}

iex(1)> 
iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:44.146 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:44.147 [debug] [pipeline@<0.551.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.97046>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:44.147 [debug] [pipeline@<0.551.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:44.147 [debug] [pipeline@<0.551.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:44.147 [debug] [pipeline@<0.551.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []


11:02:44.147 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:44.147 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source

11:02:44.147 [debug] [pipeline@<0.551.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink

11:02:44.147 [debug] [pipeline@<0.551.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:44.147 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:44.147 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink

11:02:44.147 [debug] [pipeline@<0.551.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin

11:02:44.147 [debug] [pipeline@<0.551.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []


11:02:44.147 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:44.147 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:44.147 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:44.147 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []


11:02:44.147 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:44.147 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter

11:02:44.147 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333188.97046>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333188.97046>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.97046>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333188.97046>}}], status: :done}]


11:02:44.147 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333188.97046>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:44.147 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333188.97046>}, module: Membrane.RTP.Parser

11:02:44.148 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333188.97046>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []


11:02:44.148 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.97046>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:44.148 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.97046>}] Element initialized: Membrane.RTP.Parser

11:02:44.148 [debug] [pipeline@<0.551.0>] Changing playback state from stopped to prepared

11:02:44.148 [debug] [:rtp bin] Changing playback state from stopped to prepared

11:02:44.148 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}


11:02:44.148 [debug] [:rtp bin] Playback state changed from stopped to prepared

11:02:44.148 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.551.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.97046>},
        pid: #PID<0.555.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97048>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.552.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.551.0>
}


11:02:44.149 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.551.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.97046>},
        pid: #PID<0.555.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97048>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.552.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.551.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.551.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.97046>},
        pid: #PID<0.555.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97048>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.552.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.551.0>
}


11:02:44.149 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.551.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.97046>},
        pid: #PID<0.555.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97048>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.552.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.551.0>
}


11:02:44.149 [error] GenServer #PID<0.553.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.551.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.97046>}, pid: #PID<0.555.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333188.97048>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.552.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.551.0>}
iex(1)> 
11:02:44.149 [debug] [pipeline@<0.551.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.


11:02:44.149 [debug] [pipeline@<0.551.0>] A child crashed but was not a member of any crash group.
Terminating.

iex(1)> ** (EXIT from #PID<0.550.0>) shell process exited with reason: no process: the process is not alive or there's no process currently associated with the given name, possibly because its application isn't started
iex(1)> iex(1)> 
11:02:44.149 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.551.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.97052>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.552.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.551.0>
}


11:02:44.150 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.551.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.97052>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.552.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.551.0>
}


11:02:44.150 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.551.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.97052>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.552.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.551.0>
}


11:02:44.150 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.97046>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.555.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.97046>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.97046>},
        pid: #PID<0.555.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.97079>},
        pid: #PID<0.557.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97075>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.556.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.555.0>
}


11:02:44.150 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333188.97046>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.555.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.97046>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.97046>},
        pid: #PID<0.555.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.97079>},
        pid: #PID<0.557.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97075>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.556.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.555.0>
}


11:02:44.150 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333188.97046>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.555.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.97046>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.97046>},
        pid: #PID<0.555.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.97079>},
        pid: #PID<0.557.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97075>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.556.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.555.0>
}


11:02:44.151 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.555.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.97079>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.97079>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.558.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.97079>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.97058>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.556.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.555.0>
}


11:02:44.151 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.555.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.97079>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.97079>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.558.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.97079>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.97058>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.556.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.555.0>
}


11:02:44.151 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.555.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.97079>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.97079>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.558.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.97079>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.97058>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.556.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.555.0>
}

iex(1)> 
iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:44.153 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:44.153 [debug] [pipeline@<0.561.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99385>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:44.153 [debug] [pipeline@<0.561.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:44.153 [debug] [pipeline@<0.561.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:44.153 [debug] [pipeline@<0.561.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []

iex(1)> 
11:02:44.153 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:44.153 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source
iex(1)> 
11:02:44.153 [debug] [pipeline@<0.561.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:44.154 [debug] [pipeline@<0.561.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []

iex(1)> 
11:02:44.154 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}
iex(1)> 
11:02:44.154 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:44.154 [debug] [pipeline@<0.561.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin
iex(1)> 
11:02:44.154 [debug] [pipeline@<0.561.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []

iex(1)> 
11:02:44.154 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:44.154 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:44.154 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:44.155 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []

iex(1)> 
11:02:44.155 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:44.155 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:44.155 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333187.99385>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333187.99385>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99385>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333187.99385>}}], status: :done}]

iex(1)> 
11:02:44.155 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333187.99385>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:44.155 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333187.99385>}, module: Membrane.RTP.Parser

11:02:44.155 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333187.99385>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []

iex(1)> 
11:02:44.155 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99385>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:44.155 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99385>}] Element initialized: Membrane.RTP.Parser
iex(1)> 
11:02:44.155 [debug] [pipeline@<0.561.0>] Changing playback state from stopped to prepared
iex(1)> 
11:02:44.155 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> 
11:02:44.156 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> 
11:02:44.156 [debug] [:rtp bin] Playback state changed from stopped to prepared

11:02:44.156 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.561.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99385>},
        pid: #PID<0.565.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99390>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.562.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.561.0>
}

iex(1)> 
11:02:44.156 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.561.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99385>},
        pid: #PID<0.565.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99390>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.562.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.561.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.561.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99385>},
        pid: #PID<0.565.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99390>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.562.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.561.0>
}

iex(1)> 
11:02:44.156 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.561.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99385>},
        pid: #PID<0.565.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99390>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.562.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.561.0>
}

iex(1)> 
11:02:44.156 [error] GenServer #PID<0.563.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.561.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99385>}, pid: #PID<0.565.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333187.99390>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.562.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.561.0>}

11:02:44.157 [debug] [pipeline@<0.561.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.


11:02:44.157 [debug] [pipeline@<0.561.0>] A child crashed but was not a member of any crash group.
Terminating.


11:02:44.157 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.561.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99396>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.562.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.561.0>
}


11:02:44.157 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.565.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97910>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333186.97910>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.568.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97910>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97887>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.566.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.565.0>
}


11:02:44.157 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99385>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.565.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99385>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99385>},
        pid: #PID<0.565.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333186.97910>},
        pid: #PID<0.567.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97905>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.566.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.565.0>
}


11:02:44.157 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.561.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99396>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.562.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.561.0>
}


11:02:44.158 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.561.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99396>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.562.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.561.0>
}


11:02:44.158 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.565.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97910>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333186.97910>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.568.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97910>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97887>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.566.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.565.0>
}

iex(1)> 
11:02:44.158 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333187.99385>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.565.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99385>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99385>},
        pid: #PID<0.565.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333186.97910>},
        pid: #PID<0.567.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97905>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.566.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.565.0>
}

iex(1)> ** (EXIT from #PID<0.560.0>) shell process exited with reason: no process: the process is not alive or there's no process currently associated with the given name, possibly because its application isn't started
iex(1)> iex(1)> 
11:02:44.158 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.565.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97910>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333186.97910>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.568.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333186.97910>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97887>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.566.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.565.0>
}


11:02:44.159 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333187.99385>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.565.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99385>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99385>},
        pid: #PID<0.565.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333186.97910>},
        pid: #PID<0.567.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97905>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.566.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.565.0>
}

iex(1)> 
iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:44.164 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:44.164 [debug] [pipeline@<0.571.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99412>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:44.164 [debug] [pipeline@<0.571.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:44.164 [debug] [pipeline@<0.571.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source
iex(1)> 
11:02:44.164 [debug] [pipeline@<0.571.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []

iex(1)> 
11:02:44.164 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}
iex(1)> 
11:02:44.164 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source
iex(1)> 
11:02:44.164 [debug] [pipeline@<0.571.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:44.164 [debug] [pipeline@<0.571.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []

iex(1)> 
11:02:44.165 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}
iex(1)> 
11:02:44.165 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:44.165 [debug] [pipeline@<0.571.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin
iex(1)> 
11:02:44.165 [debug] [pipeline@<0.571.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []

iex(1)> 
11:02:44.165 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:44.165 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:44.165 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:44.165 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []

iex(1)> 
11:02:44.165 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:44.165 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:44.165 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333187.99412>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333187.99412>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99412>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333187.99412>}}], status: :done}]

iex(1)> 
11:02:44.165 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333187.99412>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:44.165 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333187.99412>}, module: Membrane.RTP.Parser

11:02:44.165 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333187.99412>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []

iex(1)> 
11:02:44.166 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99412>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:44.166 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99412>}] Element initialized: Membrane.RTP.Parser
iex(1)> 
11:02:44.166 [debug] [pipeline@<0.571.0>] Changing playback state from stopped to prepared
iex(1)> iex(1)> 
11:02:44.166 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> 
11:02:44.166 [debug] [:rtp bin] Playback state changed from stopped to prepared
iex(1)> 
11:02:44.166 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> 
11:02:44.166 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.571.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99412>},
        pid: #PID<0.575.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99414>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.572.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.571.0>
}

iex(1)> 
11:02:44.167 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.571.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99412>},
        pid: #PID<0.575.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99414>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.572.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.571.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.571.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99412>},
        pid: #PID<0.575.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99414>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.572.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.571.0>
}

iex(1)> 
11:02:44.167 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.571.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99412>},
        pid: #PID<0.575.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99414>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.572.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.571.0>
}

iex(1)> 
11:02:44.167 [error] GenServer #PID<0.573.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.571.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99412>}, pid: #PID<0.575.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333187.99414>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.572.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.571.0>}
iex(1)> 
11:02:44.168 [debug] [pipeline@<0.571.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.

iex(1)> ** (EXIT from #PID<0.570.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:44.168 [debug] [pipeline@<0.571.0>] A child crashed but was not a member of any crash group.
Terminating.

iex(1)> 
iex(1)> 
11:02:44.168 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.571.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99418>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.572.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.571.0>
}

iex(1)> 
11:02:44.168 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.571.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99418>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.572.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.571.0>
}


11:02:44.168 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.571.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99418>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.572.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.571.0>
}

iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:44.168 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99412>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.575.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99412>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99412>},
        pid: #PID<0.575.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.107139>},
        pid: #PID<0.577.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97965>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.576.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.575.0>
}


11:02:44.169 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.575.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107139>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.107139>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.578.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107139>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97948>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.576.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.575.0>
}


11:02:44.169 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333187.99412>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.575.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99412>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99412>},
        pid: #PID<0.575.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.107139>},
        pid: #PID<0.577.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97965>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.576.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.575.0>
}


11:02:44.169 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.575.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107139>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.107139>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.578.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107139>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97948>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.576.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.575.0>
}


11:02:44.169 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333187.99412>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.575.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99412>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99412>},
        pid: #PID<0.575.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333185.107139>},
        pid: #PID<0.577.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333186.97965>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.576.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.575.0>
}


11:02:44.169 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.575.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107139>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333185.107139>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.578.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333185.107139>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97948>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.576.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.575.0>
}

iex(1)> 
11:02:44.243 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:44.243 [debug] [pipeline@<0.581.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99452>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:44.243 [debug] [pipeline@<0.581.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:44.243 [debug] [pipeline@<0.581.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:44.243 [debug] [pipeline@<0.581.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []

iex(1)> 
11:02:44.243 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:44.243 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source
iex(1)> 
11:02:44.243 [debug] [pipeline@<0.581.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:44.244 [debug] [pipeline@<0.581.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []

iex(1)> 
11:02:44.244 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}
iex(1)> 
11:02:44.244 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:44.244 [debug] [pipeline@<0.581.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin
iex(1)> 
11:02:44.244 [debug] [pipeline@<0.581.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []

iex(1)> 
11:02:44.244 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []

iex(1)> 
11:02:44.244 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:44.244 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:44.244 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []

iex(1)> 
11:02:44.244 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil
iex(1)> 
11:02:44.244 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:44.244 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333187.99452>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333187.99452>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99452>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333187.99452>}}], status: :done}]

iex(1)> 
11:02:44.244 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333187.99452>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:44.244 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333187.99452>}, module: Membrane.RTP.Parser

11:02:44.244 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333187.99452>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []


11:02:44.245 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99452>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:44.245 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99452>}] Element initialized: Membrane.RTP.Parser

11:02:44.245 [debug] [pipeline@<0.581.0>] Changing playback state from stopped to prepared
iex(1)> 
11:02:44.245 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> 
11:02:44.245 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> iex(1)> 
11:02:44.245 [debug] [:rtp bin] Playback state changed from stopped to prepared
iex(1)> 
11:02:44.246 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.581.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99452>},
        pid: #PID<0.585.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99457>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.582.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.581.0>
}

iex(1)> 
11:02:44.247 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.581.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99452>},
        pid: #PID<0.585.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99457>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.582.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.581.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.581.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99452>},
        pid: #PID<0.585.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99457>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.582.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.581.0>
}

iex(1)> 
11:02:44.247 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.581.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99452>},
        pid: #PID<0.585.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99457>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.582.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.581.0>
}

iex(1)> 
11:02:44.247 [error] GenServer #PID<0.583.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.581.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99452>}, pid: #PID<0.585.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333187.99457>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.582.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.581.0>}
iex(1)> 
11:02:44.247 [debug] [pipeline@<0.581.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.

iex(1)> 
11:02:44.247 [debug] [pipeline@<0.581.0>] A child crashed but was not a member of any crash group.
Terminating.

iex(1)> ** (EXIT from #PID<0.580.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:44.248 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.581.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97968>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.582.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.581.0>
}


11:02:44.248 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.581.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97968>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.582.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.581.0>
}


11:02:44.248 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.585.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99488>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99488>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.588.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99488>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99469>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.586.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.585.0>
}


11:02:44.248 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99452>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.585.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99452>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99452>},
        pid: #PID<0.585.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99488>},
        pid: #PID<0.587.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99484>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.586.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.585.0>
}


11:02:44.248 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.581.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333186.97968>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.582.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.581.0>
}

iex(1)> 
iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:44.249 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.585.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99488>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99488>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.588.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99488>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99469>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.586.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.585.0>
}

iex(1)> 
11:02:44.249 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333187.99452>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.585.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99452>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99452>},
        pid: #PID<0.585.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99488>},
        pid: #PID<0.587.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99484>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.586.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.585.0>
}


11:02:44.249 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.585.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99488>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99488>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.588.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99488>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99469>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.586.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.585.0>
}

iex(1)> 
11:02:44.249 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333187.99452>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.585.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99452>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99452>},
        pid: #PID<0.585.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99488>},
        pid: #PID<0.587.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99484>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.586.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.585.0>
}

iex(1)> 
11:02:44.249 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:44.250 [debug] [pipeline@<0.591.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.97094>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:44.250 [debug] [pipeline@<0.591.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:44.250 [debug] [pipeline@<0.591.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source
iex(1)> 
11:02:44.250 [debug] [pipeline@<0.591.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []

iex(1)> 
11:02:44.250 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}
iex(1)> 
11:02:44.250 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source
iex(1)> 
11:02:44.250 [debug] [pipeline@<0.591.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:44.250 [debug] [pipeline@<0.591.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []

iex(1)> 
11:02:44.250 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}
iex(1)> 
11:02:44.250 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink
iex(1)> 
11:02:44.250 [debug] [pipeline@<0.591.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin
iex(1)> 
11:02:44.250 [debug] [pipeline@<0.591.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []

iex(1)> 
11:02:44.250 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:44.250 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:44.250 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:44.251 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []

iex(1)> 
11:02:44.251 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil
iex(1)> 
11:02:44.251 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter
iex(1)> 
11:02:44.251 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333188.97094>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333188.97094>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.97094>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333188.97094>}}], status: :done}]

iex(1)> 
11:02:44.251 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333188.97094>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:44.251 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333188.97094>}, module: Membrane.RTP.Parser

11:02:44.251 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333188.97094>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []

iex(1)> 
11:02:44.251 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.97094>}] Initializing element: Membrane.RTP.Parser, options: nil
iex(1)> 
11:02:44.251 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.97094>}] Element initialized: Membrane.RTP.Parser
iex(1)> 
11:02:44.251 [debug] [pipeline@<0.591.0>] Changing playback state from stopped to prepared
iex(1)> 
11:02:44.251 [debug] [:rtp bin] Changing playback state from stopped to prepared
iex(1)> iex(1)> 
11:02:44.251 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}

iex(1)> 
11:02:44.251 [debug] [:rtp bin] Playback state changed from stopped to prepared
iex(1)> 
11:02:44.252 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.591.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.97094>},
        pid: #PID<0.595.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97096>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.592.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.591.0>
}

iex(1)> 
11:02:44.252 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.591.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.97094>},
        pid: #PID<0.595.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97096>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.592.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.591.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.591.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.97094>},
        pid: #PID<0.595.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97096>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.592.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.591.0>
}

iex(1)> 
11:02:44.252 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.591.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333188.97094>},
        pid: #PID<0.595.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97096>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.592.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.591.0>
}

iex(1)> 
11:02:44.252 [error] GenServer #PID<0.593.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.591.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333188.97094>}, pid: #PID<0.595.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333188.97096>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.592.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.591.0>}
iex(1)> 
11:02:44.253 [debug] [pipeline@<0.591.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.

iex(1)> ** (EXIT from #PID<0.590.0>) shell process exited with reason: shutdown: :child_crash
iex(1)> 
11:02:44.253 [debug] [pipeline@<0.591.0>] A child crashed but was not a member of any crash group.
Terminating.

iex(1)> 
11:02:44.253 [debug] [{:rtp_parser, #Reference<0.2271929081.730333188.97094>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.595.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.97094>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.97094>},
        pid: #PID<0.595.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.97121>},
        pid: #PID<0.597.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97117>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.596.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.595.0>
}

iex(1)> 
iex(1)> 
11:02:44.253 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.591.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.97100>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.592.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.591.0>
}

iex(1)> 
11:02:44.253 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.595.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.97121>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.97121>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.598.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.97121>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.97106>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.596.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.595.0>
}

iex(1)> Interactive Elixir (1.12.3) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> 
11:02:44.253 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333188.97094>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.595.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.97094>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.97094>},
        pid: #PID<0.595.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.97121>},
        pid: #PID<0.597.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97117>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.596.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.595.0>
}


11:02:44.253 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.591.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.97100>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.592.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.591.0>
}

iex(1)> 
11:02:44.254 [warn]  [{:rtp_parser, #Reference<0.2271929081.730333188.97094>}] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.595.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333188.97094>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333188.97094>},
        pid: #PID<0.595.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333188.97121>},
        pid: #PID<0.597.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333188.97117>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.596.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.595.0>
}

iex(1)> 
11:02:44.254 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.591.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.97100>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.592.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.591.0>
}


11:02:44.254 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.595.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.97121>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.97121>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.598.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.97121>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.97106>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.596.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.595.0>
}

iex(1)> 
11:02:44.254 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.595.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333188.97121>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333188.97121>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.598.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333188.97121>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333188.97106>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.596.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.595.0>
}

iex(1)> 
11:02:44.255 [debug] Pipeline start link: module: Membrane.Demo.RtpToHls.Pipeline,
pipeline options: 5000,
process options: []

iex(1)> 
11:02:44.255 [debug] [pipeline@<0.601.0>] Initializing spec
children: %{app_source: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, hls: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, rtp: Membrane.RTP.SessionBin}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: :app_source, input: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99561>}, input_props: [buffer: [fail_size: 300]], to: :rtp}], status: :done}]

iex(1)> 
11:02:44.255 [debug] [pipeline@<0.601.0>] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.Element.UDP.Source, name: :app_source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.HTTPAdaptiveStream.Sink, name: :hls, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}, %Membrane.ChildEntry{clock: nil, component_type: :bin, module: Membrane.RTP.SessionBin, name: :rtp, options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []}, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]
iex(1)> 
11:02:44.255 [debug] [pipeline@<0.601.0>] Starting child: name: :app_source, module: Membrane.Element.UDP.Source

11:02:44.255 [debug] [pipeline@<0.601.0>] Element start: :app_source
module: Membrane.Element.UDP.Source,
element options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000},
process options: []

iex(1)> ** (EXIT from #PID<0.600.0>) shell process exited with reason: no process: the process is not alive or there's no process currently associated with the given name, possibly because its application isn't started
iex(1)> iex(1)> 
11:02:44.255 [debug] [:app_source] Initializing element: Membrane.Element.UDP.Source, options: %Membrane.Element.UDP.Source{local_address: :any, local_port_no: 5000, recv_buffer_size: 500000}

11:02:44.255 [debug] [:app_source] Element initialized: Membrane.Element.UDP.Source

11:02:44.255 [debug] [pipeline@<0.601.0>] Starting child: name: :hls, module: Membrane.HTTPAdaptiveStream.Sink

11:02:44.255 [debug] [pipeline@<0.601.0>] Element start: :hls
module: Membrane.HTTPAdaptiveStream.Sink,
element options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000},
process options: []


11:02:44.255 [debug] [:hls] Initializing element: Membrane.HTTPAdaptiveStream.Sink, options: %Membrane.HTTPAdaptiveStream.Sink{manifest_module: Membrane.HTTPAdaptiveStream.HLS, manifest_name: "index", persist?: false, storage: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{directory: "output"}, target_segment_duration: 0, target_window_duration: 10000000000}

11:02:44.255 [debug] [:hls] Element initialized: Membrane.HTTPAdaptiveStream.Sink

11:02:44.255 [debug] [pipeline@<0.601.0>] Starting child: name: :rtp, module: Membrane.RTP.SessionBin

11:02:44.255 [debug] [pipeline@<0.601.0>] Bin start link: name: :rtp
module: Membrane.RTP.SessionBin,
bin options: %Membrane.RTP.SessionBin{custom_depayloaders: %{}, custom_payloaders: %{}, fmt_mapping: %{}, receiver_srtp_policies: nil, receiver_ssrc_generator: &Membrane.RTP.SessionBin.generate_receiver_ssrc/2, rtcp_interval: 5000000000, secure?: false, srtp_policies: []},
process options: []


11:02:44.256 [debug] [:rtp bin] Initializing spec
children: [ssrc_router: Membrane.RTP.SSRCRouter]
links: []


11:02:44.256 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.SSRCRouter, name: :ssrc_router, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:44.256 [debug] [:rtp bin] Starting child: name: :ssrc_router, module: Membrane.RTP.SSRCRouter

11:02:44.256 [debug] [:rtp bin] Element start: :ssrc_router
module: Membrane.RTP.SSRCRouter,
element options: nil,
process options: []


11:02:44.256 [debug] [:ssrc_router] Initializing element: Membrane.RTP.SSRCRouter, options: nil

11:02:44.256 [debug] [:ssrc_router] Element initialized: Membrane.RTP.SSRCRouter

11:02:44.256 [debug] [:rtp bin] Initializing spec
children: %{{:rtp_parser, #Reference<0.2271929081.730333187.99561>} => Membrane.RTP.Parser}
links: [%Membrane.ParentSpec.LinkBuilder{children: [], links: [%{from: {:rtp_parser, #Reference<0.2271929081.730333187.99561>}, to: :ssrc_router}, %{from: {Membrane.Bin, :itself}, output: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99561>}, output_props: [buffer: [warn_size: 250, fail_size: 500]], to: {:rtp_parser, #Reference<0.2271929081.730333187.99561>}}], status: :done}]


11:02:44.256 [debug] [:rtp bin] Starting children: [%Membrane.ChildEntry{clock: nil, component_type: :element, module: Membrane.RTP.Parser, name: {:rtp_parser, #Reference<0.2271929081.730333187.99561>}, options: nil, pid: nil, playback_synced?: false, sync: nil, terminating?: false}]

11:02:44.256 [debug] [:rtp bin] Starting child: name: {:rtp_parser, #Reference<0.2271929081.730333187.99561>}, module: Membrane.RTP.Parser

11:02:44.256 [debug] [:rtp bin] Element start: {:rtp_parser, #Reference<0.2271929081.730333187.99561>}
module: Membrane.RTP.Parser,
element options: nil,
process options: []


11:02:44.256 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99561>}] Initializing element: Membrane.RTP.Parser, options: nil

11:02:44.256 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99561>}] Element initialized: Membrane.RTP.Parser

11:02:44.256 [debug] [pipeline@<0.601.0>] Changing playback state from stopped to prepared

11:02:44.256 [debug] [:rtp bin] Changing playback state from stopped to prepared

11:02:44.256 [error] [:app_source] Callback :handle_stopped_to_prepared from module Membrane.Element.UDP.Source returned an error
Internal state: %{
  local_socket: %Membrane.Element.UDP.Socket{
    ip_address: :any,
    port_no: 5000,
    sock_opts: [recbuf: 500000],
    socket_handle: nil
  }
}


11:02:44.257 [debug] [:rtp bin] Playback state changed from stopped to prepared

11:02:44.257 [error] [:app_source] MessageDispatcher: cannot handle message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info
Reason: :eaddrinuse
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.601.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99561>},
        pid: #PID<0.605.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99566>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.602.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.601.0>
}


11:02:44.257 [error] [:app_source] Terminating GenServer, reason: {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]},
old state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.601.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99561>},
        pid: #PID<0.605.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99566>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :stopped
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.602.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.601.0>
},
new state: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.601.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99561>},
        pid: #PID<0.605.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99566>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.602.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.601.0>
}


11:02:44.257 [warn]  [:app_source] Terminating element possibly not prepared for termination as it was in state :stopped.
Reason: {:error, {:cannot_handle_message, :eaddrinuse, [message: {Membrane.Core.Message, :change_playback_state, :prepared, []}, mode: :info]}}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.601.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    local_socket: %Membrane.Element.UDP.Socket{
      ip_address: :any,
      port_no: 5000,
      sock_opts: [recbuf: 500000],
      socket_handle: nil
    }
  },
  module: Membrane.Element.UDP.Source,
  name: :app_source,
  pads: %{
    data: %{
      output: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream, [type: :packetized]},
        availability: :always,
        caps: nil,
        demand: nil,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :push,
        name: :output,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, :rtp_input,
         #Reference<0.2271929081.730333187.99561>},
        pid: #PID<0.605.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99566>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :stopped,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.602.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :source,
  watcher: #PID<0.601.0>
}


11:02:44.257 [error] GenServer #PID<0.603.0> terminating
** (stop) exited in: :cannot_handle_message.eaddrinuse({:message, {Membrane.Core.Message, :change_playback_state, :prepared, []}}, {:mode, :info})
    ** (EXIT) :error
Last message: {Membrane.Core.Message, :change_playback_state, :prepared, []}
State: %Membrane.Core.Element.State{controlling_pid: #PID<0.601.0>, delayed_demands: #MapSet<[]>, internal_state: %{local_socket: %Membrane.Element.UDP.Socket{ip_address: :any, port_no: 5000, sock_opts: [recbuf: 500000], socket_handle: nil}}, module: Membrane.Element.UDP.Source, name: :app_source, pads: %{data: %{output: %Membrane.Pad.Data{accepted_caps: {Membrane.RemoteStream, [type: :packetized]}, availability: :always, caps: nil, demand: nil, demand_unit: nil, direction: :output, end_of_stream?: false, input_buf: nil, mode: :push, name: :output, options: nil, other_demand_unit: nil, other_ref: {Membrane.Pad, :rtp_input, #Reference<0.2271929081.730333187.99561>}, pid: #PID<0.605.0>, ref: :output, start_of_stream?: false, sticky_messages: nil}}, dynamic_currently_linking: [], info: %{}}, parent_monitor: #Reference<0.2271929081.730333187.99566>, playback: %Membrane.Core.Playback{async_state_change: false, pending_state: nil, state: :stopped, target_state: :prepared}, playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>}, supplying_demand?: false, synchronization: %{clock: nil, latency: 0, parent_clock: #PID<0.602.0>, stream_sync: :membrane_no_sync, timers: %{}}, type: :source, watcher: #PID<0.601.0>}

11:02:44.257 [debug] [pipeline@<0.601.0>] Pipeline child crashed but was not a member of any crash group.
Terminating.


11:02:44.257 [debug] [pipeline@<0.601.0>] A child crashed but was not a member of any crash group.
Terminating.


11:02:44.258 [debug] [:hls] Shutting down because of pipeline failure
Reason: {:shutdown, :child_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.601.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99570>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.602.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.601.0>
}


11:02:44.258 [debug] [:ssrc_router] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.605.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99595>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99595>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: :output,
        pid: #PID<0.608.0>,
        ref: {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99595>},
        start_of_stream?: false,
        sticky_messages: []
      }
    },
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      },
      output: %{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        direction: :output,
        mode: :pull,
        name: :output,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99576>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.606.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.605.0>
}


11:02:44.258 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :child_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.601.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99570>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.602.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.601.0>
}

iex(1)> 
iex(1)> 
11:02:44.258 [debug] [{:rtp_parser, #Reference<0.2271929081.730333187.99561>}] Shutting down because of pipeline failure
Reason: {:shutdown, :parent_crash}
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.605.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{},
  module: Membrane.RTP.Parser,
  name: {:rtp_parser, #Reference<0.2271929081.730333187.99561>},
  pads: %{
    data: %{
      input: %Membrane.Pad.Data{
        accepted_caps: {Membrane.RemoteStream,
         [type: :packetized, content_format: one_of([nil, Membrane.RTP])]},
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: ":input",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: true,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: :input,
        options: nil,
        other_demand_unit: nil,
        other_ref: {Membrane.Pad, {:private, :rtp_input},
         #Reference<0.2271929081.730333187.99561>},
        pid: #PID<0.605.0>,
        ref: :input,
        start_of_stream?: false,
        sticky_messages: []
      },
      output: %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :always,
        caps: nil,
        demand: 0,
        demand_unit: nil,
        direction: :output,
        end_of_stream?: false,
        input_buf: nil,
        mode: :pull,
        name: :output,
        options: nil,
        other_demand_unit: :buffers,
        other_ref: {Membrane.Pad, :input,
         #Reference<0.2271929081.730333187.99595>},
        pid: #PID<0.607.0>,
        ref: :output,
        start_of_stream?: false,
        sticky_messages: nil
      }
    },
    dynamic_currently_linking: [],
    info: %{}
  },
  parent_monitor: #Reference<0.2271929081.730333187.99591>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{
    q: #Qex<[{Membrane.Core.Message, :demand, 40, [for_pad: :output]}]>
  },
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.606.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :filter,
  watcher: #PID<0.605.0>
}


11:02:44.258 [warn]  [:hls] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.601.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %{
    awaiting_first_segment: #MapSet<[]>,
    manifest: %Membrane.HTTPAdaptiveStream.Manifest{
      module: Membrane.HTTPAdaptiveStream.HLS,
      name: "index",
      tracks: %{}
    },
    persist?: false,
    storage: %Membrane.HTTPAdaptiveStream.Storage{
      cache: %{},
      cache_enabled?: true,
      impl_state: %Membrane.HTTPAdaptiveStream.Storages.FileStorage{
        directory: "output"
      },
      storage_impl: Membrane.HTTPAdaptiveStream.Storages.FileStorage,
      stored_manifests: #MapSet<[]>
    },
    target_segment_duration: 0,
    target_window_duration: 10000000000
  },
  module: Membrane.HTTPAdaptiveStream.Sink,
  name: :hls,
  pads: %{
    data: %{},
    dynamic_currently_linking: [],
    info: %{
      input: %{
        accepted_caps: Membrane.CMAF.Track,
        availability: :on_request,
        demand_unit: :buffers,
        direction: :input,
        mode: :pull,
        name: :input,
        options: nil
      }
    }
  },
  parent_monitor: #Reference<0.2271929081.730333187.99570>,
  playback: %Membrane.Core.Playback{
    async_state_change: false,
    pending_state: nil,
    state: :prepared,
    target_state: :prepared
  },
  playback_buffer: %Membrane.Core.Element.PlaybackBuffer{q: #Qex<[]>},
  supplying_demand?: false,
  synchronization: %{
    clock: nil,
    latency: 0,
    parent_clock: #PID<0.602.0>,
    stream_sync: :membrane_no_sync,
    timers: %{}
  },
  type: :sink,
  watcher: #PID<0.601.0>
}


11:02:44.259 [warn]  [:ssrc_router] Terminating element possibly not prepared for termination as it was in state :prepared.
Reason: {:shutdown, :parent_crash}",
State: %Membrane.Core.Element.State{
  controlling_pid: #PID<0.605.0>,
  delayed_demands: #MapSet<[]>,
  internal_state: %Membrane.RTP.SSRCRouter.State{
    linking_buffers: %{},
    pads: %{}
  },
  module: Membrane.RTP.SSRCRouter,
  name: :ssrc_router,
  pads: %{
    data: %{
      {Membrane.Pad, :input, #Reference<0.2271929081.730333187.99595>} => %Membrane.Pad.Data{
        accepted_caps: Membrane.RTP,
        availability: :on_request,
        caps: nil,
        demand: 0,
        demand_unit: :buffers,
        direction: :input,
        end_of_stream?: false,
        input_buf: %Membrane.Core.InputBuffer{
          current_size: 0,
          demand: 0,
          log_tag: "{Membrane.Pad, :input, #Reference<0.2271929081.730333187.99595>}",
          metric: Membrane.Buffer.Metric.Count,
          min_demand: 10,
          preferred_size: 40,
          q: #Qex<[]>,
          toilet?: false,
          toilet_props: %{fail: 160, warn: 80}
        },
        mode: :pull,
        name: 